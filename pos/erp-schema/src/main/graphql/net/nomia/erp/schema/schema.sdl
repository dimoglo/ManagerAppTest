# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

directive @ActivityPeriod(message: String) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @BigDecimalScale(roundingMode: String!, scale: Int!) on FIELD_DEFINITION

directive @ContainerNotEmpty(message: String) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Digits(fraction: Int!, integer: Int!, message: String) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Email on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Login on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Max(value: Int! = 2147483647) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @NotBlank on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @NotEmpty(message: String) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @NotNull on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @PasswordStrength on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Patch on FIELD_DEFINITION

directive @Pattern(message: String, regexp: String!) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Positive(message: String) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @PositiveOrZero(message: String) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Range(max: Int, message: String, min: Int) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Size(max: Int, message: String, min: Int) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @SizeOrEmpty(allowEmpty: Boolean, max: Int, message: String, min: Int) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Sizes(allowEmpty: Boolean, message: String, sizes: [Int!]!) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @SnilsChecksum on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @VatinChecksum on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

interface ApiException {
    message: String
}

interface KKTDocument {
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int
    documentType: DocumentType
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String
    ofdTicket: OfdTicket
    registrationNumber: String
    shiftNumber: Int
}

"Page with metadata"
interface Page {
    "Current page number"
    pageNumber: Int!
    "The number of items on that page"
    pageSize: Int!
    "The total amount of available items"
    total: Int!
    "Count of available pages"
    totalPages: Int!
}

interface RequestResult {
    "Error message in case of failure"
    errorMessage: String
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

union AppliedModifier = StockUnitAppliedModifier | TextAppliedModifier

union AppliedOrderDiscount = AppliedLoyalty | AppliedOrderDiscountSnapshot | AppliedOrderItemDiscountSnapshot

"Employee changes subscriptions types"
union EmployeeChange = EmployeeCreated | EmployeeRemoved | EmployeeUpdated

"other types"
union InCatalogResponse = CatalogSection | Product

union KKTDocumentUnion = CorrectionDocument | FiscalDocument | ReRegistrationDocument | RegistrationDocument | ShiftClosingDocument | ShiftOpeningDocument

union MenuElement = MenuItem | MenuSection

"Abstract menu item event to subscribe to"
union MenuItemSubscriptionDto = MenuItemCreatedDto | MenuItemDeletedDto | MenuItemUpdatedDto

union MenuSectionSubscriptionDto = MenuSectionCreatedDto | MenuSectionDeletedDto | MenuSectionUpdatedDto

union Modifier = StockUnitModifier | TextModifier

union Notification = PaymentCardNotBoundNotification | PaymentInvoiceCreatedNotification | SubscriptionsCancellationNotification | SubscriptionsDueToExpireNotification | SuccessfulPaymentNotification | UnsuccessfulPaymentNotification | XlsReportCreationStartedNotification | XlsReportGeneratedNotification

union NotificationAction = GraphQLNotificationAction | URLNotificationAction

"Abstract order event to subscribe to"
union OrderEvent = OrderCreatedEvent | OrderDeletedEvent | OrderUpdatedEvent

union PaySystemEvent = PaySystemCreatedEvent | PaySystemRemovedEvent | PaySystemUpdatedEvent

union PointTransaction = PointTransactionManual | PointTransactionOrder

union PromotionProgramsUnion = BonusProgram | DiscountProgram

union SignInRequestError = SignInRequestRateLimitError

"Abstract stock unit event to subscribe to"
union StockUnitSubscriptionDto = StockUnitCreatedDto | StockUnitDeletedDto | StockUnitUpdatedDto

union StoreSubscriptionDto = StoreDeletedDto | StoreUpdatedDto

union TableBookingSubscriptionResult = TableBookingCreated | TableBookingUpdated

"Popular product (which is also called ABC product) which most revenue for the selected period"
type ABCReport {
    "name of the product"
    name: String!
    "product profit for the selected period"
    profit: BigDecimal!
    "margin on product sales for the selected period"
    profitPercent: BigDecimal!
    "percent of margin for current product out of others"
    profitPercentOutOfTotal: BigDecimal!
    "product sales quantity for the selected period"
    quantity: BigDecimal!
    "product revenue for the selected period"
    revenue: BigDecimal!
    "product unitType"
    unitType: UnitType!
}

type AbcReportOutput {
    rows(pageRequest: PageRequestInput, sort: [AbcReportV2Sort!]): AbcReportV2Page!
    total: AbcReportV2Total!
}

type AbcReportV2 {
    categories: [CategorySnapshot!]
    name: String!
    productType: ProductType!
    profit: BigDecimal!
    profitPercent: BigDecimal!
    profitPercentOutOfTotal: BigDecimal!
    quantity: BigDecimal!
    revenue: BigDecimal!
    revenuePercentOutOfTotal: BigDecimal!
    unitType: UnitType!
}

type AbcReportV2Page implements Page {
    content: [AbcReportV2!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type AbcReportV2Total {
    percentageProfit: BigDecimal!
    percentageRevenue: BigDecimal!
    profit: BigDecimal!
    quantity: BigDecimal!
    revenue: BigDecimal!
}

"Accept employee invite response"
type AcceptEmployeeInviteResponse {
    employeeId: UUID!
}

type Account {
    "Describes account accessibility"
    active: Boolean!
    "Avatar image"
    avatarUrl: String
    "IDs of employments for current user"
    employeeIds: [UUID!]
    "Employees list"
    employees: [Employee]
    firstName: String!
    "Is password set for this account"
    hasPassword: Boolean!
    "User ID"
    id: UUID!
    "Available logins for this user"
    identities: [Identity!]
    "Identity claims"
    identityClaims: [IdentityClaim!]
    "Account's avatar image id"
    imageId: UUID
    lastName: String!
    middleName: String
    "Describes that user passed through Nomia welcome tutorial"
    onboarded: Boolean!
    pin: String
    roles: [RoleCode!]
    "Is this account tech support member"
    supportAssistant: Boolean!
    "Human-friendly user ID"
    userId: Int!
    workEmail: String!
    workPhone: String
}

type AccountNotification {
    isRead: Boolean!
    notification: Notification!
}

"Period when discount is active"
type ActivityPeriod {
    "Periods of time within days when discount is active (for `periodType == SCHEDULED`)"
    dailyPeriods: [DailyPeriod!]
    "Days of week when discount is active (for `periodType == SCHEDULED`)"
    daysOfWeek: [DayOfWeek!] @deprecated(reason: "Use dailyPeriods instead")
    "Activity period ID"
    id: UUID!
    "Maximum date when discount is active (for `periodType == TEMPORARY`)"
    maxDate: LocalDate
    "Maximum time of day when discount is active (for `periodType == SCHEDULED`)"
    maxTime: LocalTime @deprecated(reason: "Use dailyPeriods instead")
    "Minimal date when discount is active (for `periodType == TEMPORARY`)"
    minDate: LocalDate
    "Minimal time of day when discount is active (for `periodType == SCHEDULED`)"
    minTime: LocalTime @deprecated(reason: "Use dailyPeriods instead")
    "Type"
    periodType: PeriodType
}

type Addon {
    description: String!
    id: UUID!
    name: String!
    price: AmountData!
    terms: [AddonTerms!]!
}

type AddonPage implements Page {
    content: [Addon!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type AddonSubscription {
    addon: Addon!
    quantity: Int!
}

type AddonTerms {
    deviceType: TermsDeviceType!
    limit: Int!
}

type AddressSearchDTO {
    address: String
    fullAddress: String
    latitude: String
    longitude: String
    postalCode: String
    timezone: String
}

type AddressSearchResponse {
    addressSearchDTOList: [AddressSearchDTO]!
}

type AllImageWithSizes {
    "array of images with size and url"
    images: [ImagesWithSize!]!
}

"Measure of value for money type"
type AmountData {
    "Value of money"
    amountValue: BigDecimal!
    "Money currency"
    currencyUnit: String!
}

"Data grouped by day of week for the selected period"
type AnalyticsByDayOfWeek {
    "dayly average check"
    averageWeeklyCheck: BigDecimal!
    "dayly average checks count"
    averageWeeklyProfit: BigDecimal!
    "dayly average revenue"
    averageWeeklyRevenue: BigDecimal!
    "at which day of week data has been collected, from 0 - sunday to 6 - saturday"
    dayOfWeek: Int!
    "dayly average checks count"
    totalWeeklyChecksCount: Int!
    "dayly average guests count"
    totalWeeklyGuestsCount: Int!
}

"Data grouped by hour for the selected period"
type AnalyticsByHour {
    "hourly average check"
    averageHourlyCheck: BigDecimal!
    "hourly average profit"
    averageHourlyProfit: BigDecimal!
    "hourly average revenue"
    averageHourlyRevenue: BigDecimal!
    "at which hour data has been collected"
    hour: Int!
    "hourly average checks count"
    totalHourlyChecksCount: Int!
    "hourly average guests count"
    totalHourlyGuestsCount: Int!
}

"Data grouped by day for the selected period"
type AnalyticsChartReport {
    "daily averageCheck"
    averageCheck: BigDecimal!
    "daily checks count"
    checksCount: Int!
    "at which day data has been collected"
    date: LocalDate!
    "daily guests count"
    guestsCount: Int!
    "daily profit"
    profit: BigDecimal!
    "quantity"
    quantity: Int!
    "daily revenue"
    revenue: BigDecimal!
    "quantity"
    stockUnitQuantity: BigDecimal!
}

"Data grouped by hour for the selected period"
type AnalyticsChartReportHourly {
    "daily averageCheck"
    averageCheck: BigDecimal!
    "daily checks count"
    checksCount: Int!
    "at which day data has been collected"
    date: LocalDateTime!
    "daily guests count"
    guestsCount: Int!
    "daily profit"
    profit: BigDecimal!
    "stockUnit quantity if stockUnit has been provided"
    quantity: Int!
    "daily revenue"
    revenue: BigDecimal!
    "stockUnit quantity if stockUnit has been provided"
    stockUnitQuantity: BigDecimal!
}

"data for given period"
type AnalyticsChartReportSummary {
    "all average check for the selected period"
    averageCheck: BigDecimal!
    "all checks count for the selected period"
    checksCount: Int!
    "all guests count for the selected period"
    guestsCount: Int!
    "all profit for the selected period"
    profit: BigDecimal!
    "all quantity of a stockUnit for the selected period"
    quantity: BigDecimal!
    "all revenue for the selected period"
    revenue: BigDecimal!
    "stockUnit unitType"
    unitType: UnitType!
}

type AnalyticsWarehouseItemMoveHistoriesDetails {
    arrivalDuringPeriod: BigDecimal
    primePriceAtEndOfPeriod: AmountData
    primePriceAtStartOfPeriod: AmountData
    productName: String
    productType: ProductType
    quantityAtEndOfPeriod: BigDecimal
    quantityAtStartOfPeriod: BigDecimal
    sectionName: String
    stockUnitId: UUID
    unitType: UnitType
    warehouseName: String
    writtenOffDuringPeriod: BigDecimal
}

type AnalyticsWarehouseItemMoveHistoriesDetailsPage implements Page {
    content: [AnalyticsWarehouseItemMoveHistoriesDetails!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type AnalyticsWarehouseItemMoveHistory {
    coreItemId: UUID
    coreItemName: String
    date: Instant!
    docNumber: Long!
    documentId: UUID!
    event: WarehouseItemEvent!
    initialQuantity: BigDecimal!
    name: String!
    quantity: BigDecimal!
    reason: WarehouseItemReasonEvent!
    remainsQuantity: BigDecimal!
    stockUnitId: UUID!
    storeId: UUID
    unit: UnitType
    warehouseId: UUID!
    warehouseName: UUID!
}

type AnalyticsWarehouseItemMoveHistoryDetails {
    "Arrival"
    arrival: BigDecimal
    docNumber: Long
    documentDate: Instant
    documentId: UUID
    event: WarehouseItemEvent
    "Prime price after this document"
    newPrimePrice: AmountData
    "Amount after this document"
    newQuantity: BigDecimal
    "Prime price before this document"
    previousPrimePrice: AmountData
    "Amount before this document"
    previousQuantity: BigDecimal
    "Previous item move unit type"
    previousUnit: UnitType
    "Changing amount of document"
    quantity: BigDecimal
    reason: WarehouseItemReasonEvent
    stockUnitName: String
    unit: UnitType
    warehouseName: String
    "Written off"
    writtenOff: BigDecimal
}

type AnalyticsWarehouseItemMoveHistoryDetailsPage implements Page {
    content: [AnalyticsWarehouseItemMoveHistoryDetails!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type AnalyticsWarehouseItemMoveHistoryPage implements Page {
    content: [AnalyticsWarehouseItemMoveHistory!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Discount applied to the order"
type AppliedDiscount {
    "Binding discounts to catalog items (the catalog itself, sections and products)"
    bindings: [AppliedDiscountBinding!]
    "Discount Id"
    discountId: UUID
    "Discount name"
    discountName: String
    "Discount type"
    discountType: DiscountType
    "The number of items in the cart for applying a discount with the type` COUNTED` "
    freeQuantity: Int
    "Id of applying discount to order"
    id: UUID
    "Discount percentage"
    percent: BigDecimal
    "Discount period"
    period: AppliedDiscountActivityPeriod
}

"Discount period"
type AppliedDiscountActivityPeriod {
    "Periods of time whithin days when discount is active (for type `SCHEDULED`)"
    dailyPeriods: [AppliedDiscountDailyPeriod!]
    "Days of the week in which the discount is valid (for type` SCHEDULED`) "
    daysOfWeek: [DayOfWeek!] @deprecated(reason: "Use dailyPeriods instead")
    "Id of the discount period"
    id: UUID
    "Maximum discount validity date (for the` TEMPORARY` type) "
    maxDate: LocalDate
    "The maximum duration of the discount (for the type` SCHEDULED`) "
    maxTime: LocalTime @deprecated(reason: "Use dailyPeriods instead")
    "The minimum validity date of the discount (for the type` TEMPORARY`) "
    minDate: LocalDate
    "The minimum duration of the discount (for the type` SCHEDULED`) "
    minTime: LocalTime @deprecated(reason: "Use dailyPeriods instead")
    "Period type"
    periodType: PeriodType
}

"Linking a discount to a catalog item"
type AppliedDiscountBinding {
    "The quantity of goods for this binding in the cart, for which a discount with the` COMBO` type is applied "
    amount: BigDecimal
    "Id of the related entity"
    entityId: UUID
    "Related entity type"
    entityType: BoundEntityType
    "Bind Id"
    id: UUID
}

"Scheduled discount daily activity period"
type AppliedDiscountDailyPeriod {
    "Day of week for which the activity period is set"
    dayOfWeek: DayOfWeek!
    "Maximum time of day when discount is active"
    maxTime: LocalTime!
    "Minimal time of day when discount is active"
    minTime: LocalTime!
}

type AppliedLoyalty {
    amount: BigDecimal!
    appliedId: UUID!
    id: UUID!
    name: String!
}

type AppliedModifierGroup {
    entityId: UUID!
    entityName: String!
    entityType: ModifierEntityType!
    maxValue: Int!
    minValue: Int!
    modifierGroupId: UUID!
    name: String!
    required: Boolean!
    type: ModifierType!
}

type AppliedOrderDiscountSnapshot {
    amount: BigDecimal!
    appliedId: UUID!
    id: UUID!
    name: String!
}

type AppliedOrderItemDiscountSnapshot {
    amount: BigDecimal!
    appliedId: UUID!
    id: UUID!
    name: String!
}

"Arrival document data"
type ArrivalDocument {
    "Creation date"
    creationDate: Instant
    "Execution date"
    date: Instant
    "Description"
    description: String
    "Number"
    docNumber: Long
    "Arrived items"
    documentItems: [DocumentItem!]
    "Arrival document ID"
    id: UUID
    "Organization that created the document"
    organization: Organization
    "Status"
    status: StatusDocument
    "Supplier of arrival"
    supplier: Supplier
    "Warehouse of arrival"
    to: Warehouse
    "Total document item's amount"
    totalAmount: BigDecimal!
    "Type"
    typeDocument: TypeDocument
}

type ArrivalDocumentPage implements Page {
    content: [ArrivalDocument!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ArrivalDocumentResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: ArrivalDocument
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

"Second-phase auth response, contains access token & refresh token"
type AuthData {
    "Access token: short duration token, required for every permission-required request, must be passed in 'Authorization' header with 'Bearer' prefix"
    accessToken: String!
    "Refresh token: long lifetime token, required to renew previously issued access token, can be used only once; must be passed in 'RefreshToken' header without prefix"
    refreshToken: String!
}

type BankSearchResponse {
    bic: String!
    correspondentAccount: String!
    name: String!
}

type Barcode {
    code: String!
    id: UUID!
}

type Bill {
    accountingPeriod: DateRange!
    amount: AmountData
    billNumber: Int!
    discount: AmountData
    id: UUID!
    items: [BillItem!]!
    organizationId: UUID!
    paymentDate: LocalDate
    status: BillStatus!
    totalAmount: AmountData!
}

type BillItem {
    amount: AmountData
    discount: AmountData
    id: UUID!
    name: String
    price: AmountData
    quantity: Int!
}

type BillPage implements Page {
    content: [Bill!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type BonusProgram {
    bonusProgramType: BonusProgramType!
    id: UUID!
    pointPrice: PointPrice!
    promotionProgram: PromotionProgram!
}

type BonusProgramResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: BonusProgram
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

"Get all information for provided type (warehouse, catalog, store)"
type BoundOverview {
    "all warehouses for selected type"
    catalogs: [Catalog!]!
    "id of an essence"
    id: UUID!
    "all menus for selected type"
    menus: [Menu!]!
    "all stores for selected type"
    stores: [Store!]!
    "type for which data will be collected, if warehouses then search all catalogs and stores with selected warehouse. If type is catalog then search all warehouses and stores for catalog"
    type: Type!
    "all warehouses for selected type"
    warehouses: [Warehouse!]!
}

type CachedCategory {
    categories: [CachedCategory!]
    id: UUID!
    name: String!
    products: [CachedProduct!]
}

type CachedProduct {
    id: UUID!
    name: String!
    stockUnitId: UUID!
}

"Catalog output data"
type Catalog {
    "Count of products contained in the catalog"
    countOfProducts: Int
    "Count of sections contained in the catalog"
    countOfSections: Int
    "Catalog ID"
    id: UUID!
    "Catalog name"
    name: String!
    "Organization which the catalog belongs to"
    organization: Organization!
    "Catalog position type with source info"
    positionType: PositionType
    "Catalog SNO (taxation system) with source info"
    snoValue: SnoValue
    "Catalog TaxProfile"
    taxProfile: TaxProfile @deprecated(reason: "use snoValue & taxValue")
    "Catalog VAT (tax rate) with source info"
    vatValue: VatValue
}

type CatalogResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Catalog
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

"Section output data"
type CatalogSection {
    "Catalog which the section belongs to"
    catalog: Catalog!
    "Section color"
    color: CatalogSectionColor! @deprecated(reason: "use colorSection")
    "Color section"
    colorSection: ColorSection
    "Section depth level"
    depthLevel: Int!
    "Section ID"
    id: UUID!
    "Section image"
    image: Image
    "Whether the section is the parent"
    isParent: Boolean!
    "Section labels"
    labels: [String!]!
    "Section left margin in the tree"
    leftMargin: Int!
    modifierGroups: [ModifierGroup!]!
    "Section name"
    name: String!
    nestedCounts: CategoryNestedCounts
    "Parent section, if present"
    parent: CatalogSection
    "Position type of nearest parent catalog element, if available"
    parentPositionType: PositionType
    "SNO (taxation system) of nearest parent catalog element, if available"
    parentSnoValue: SnoValue
    "VAT (tax rate) of nearest parent catalog element, if available"
    parentVatValue: VatValue
    "Section position type with source info"
    positionType: PositionType
    "Section products"
    products: [Product!]!
    "Products quantity in section, not includes nested sections"
    productsCount: Long!
    "Section right margin in the tree"
    rightMargin: Int!
    "Section SNO (taxation system) with source info"
    snoValue: SnoValue
    "Section TaxProfile"
    taxProfile: TaxProfile @deprecated(reason: "use snoValue & taxValue")
    "Section VAT (tax rate) with source info"
    vatValue: VatValue
}

"Section color"
type CatalogSectionColor {
    "Color code in hex"
    code: String!
    "Color name"
    name: String!
}

"Page of catalog sections"
type CatalogSectionPage implements Page {
    content: [CatalogSection!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type CatalogSectionResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: CatalogSection
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type CategoryNestedCounts {
    "Categories count in current and nested sections"
    categoryCount: Int!
    "Products count in current and nested sections"
    productCount: Int!
}

type CategoryReport {
    categories: [CategorySnapshot!]
    categoryId: UUID!
    categoryName: String!
    foodCost: Int!
    kilogramQuantity: BigDecimal!
    literQuantity: BigDecimal!
    ordersQuantity: Int!
    pieceQuantity: BigDecimal!
    primePrice: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
    tax: BigDecimal!
}

type CategoryReportOutput {
    rows(pageRequest: PageRequestInput, sort: [CategoryReportSort!]): CategoryReportPage!
    total: CategoryReportTotal!
}

type CategoryReportPage implements Page {
    content: [CategoryReport!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type CategoryReportTimeSeries {
    foodCost: Int!
    profit: BigDecimal!
    recordedAt: Instant!
    revenue: BigDecimal!
}

type CategoryReportTotal {
    foodCost: Int!
    kilogramQuantity: BigDecimal!
    literQuantity: BigDecimal!
    ordersQuantity: Int!
    pieceQuantity: BigDecimal!
    primePrice: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
    tax: BigDecimal!
}

type CategorySnapshot {
    id: UUID!
    name: String!
}

type Client {
    email: String
    name: String
    phone: String
    vatin: String
}

type ConfirmSupportControlClaimResult {
    id: UUID!
}

type ConsolidatedReport {
    averageCheck: BigDecimal!
    discount: BigDecimal!
    guestCount: Int!
    ordersCount: Int!
    profit: BigDecimal!
    revenue: BigDecimal!
    timestamp: Instant!
}

type ConsolidatedReportOutput {
    rows(pageRequest: PageRequestInput, sort: [ConsolidatedReportSort!]): ConsolidatedReportPage!
    total: ConsolidatedReportTotal!
}

type ConsolidatedReportPage {
    content: [ConsolidatedReport!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ConsolidatedReportTimeSeries {
    averageCheck: BigDecimal!
    discount: BigDecimal!
    guestCount: Int!
    ordersCount: Int!
    profit: BigDecimal!
    revenue: BigDecimal!
    timestamp: Instant!
}

type ConsolidatedReportTotal {
    averageCheck: BigDecimal!
    discount: BigDecimal!
    guestCount: Int!
    ordersCount: Int!
    profit: BigDecimal!
    revenue: BigDecimal!
}

type ConsolidatedReportXlsOutput {
    url: String!
}

type ConsolidatedTimeSeriesOutput {
    elements: [ConsolidatedReportTimeSeries!]!
}

type ConvertableUnit {
    convertableQuantity: BigDecimal!
    convertableUnitType: UnitType!
}

type Coordinates {
    "latitude (e.g. of Moscow is 55.75000)"
    latitude: Float!
    "longitude (e.g. of Moscow is 37.62100)"
    longitude: Float!
}

type CorrectionDocument implements KKTDocument {
    checksum: String
    "An RFC-3339 compliant DateTime"
    correctionBaseDate: DateTime
    correctionBaseName: String
    correctionBaseNumber: String
    correctionType: CorrectionType
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int
    documentType: DocumentType
    electronically: Boolean
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String
    items: [ReceiptItemWrapper]
    ofd: Ofd
    ofdTicket: OfdTicket
    operator: Operator
    orderId: UUID
    organizationName: String
    organizationVatin: String
    payments: [Payment]
    receiptType: CorrectionReceiptType
    registrationNumber: String
    roundTotal: Boolean
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
}

type CreateTableBookingResult implements RequestResult {
    errorMessage: String
    output: TableBooking
    result: TransactionResult!
    transactionId: UUID
}

type CreditLoyalty {
    active: Boolean!
    beginsAt: LocalDate
    customerGroups(pageRequest: PageRequestInput): CustomerGroupPage
    description: String
    endsAt: LocalDate
    id: UUID!
    image: Image
    name: String!
    pointPrice: BigDecimal!
    storeBindings: [LoyaltyStoreBinding!]!
}

type CreditLoyaltyBinding {
    entityId: UUID!
    entityType: BoundEntityType!
    stockUnitIds: [UUID!]
}

type CreditLoyaltyPage implements Page {
    content: [CreditLoyalty!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type CreditLoyaltyResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: CreditLoyalty
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type Customer {
    address: CustomerAddress
    age: Int
    cardNumber: String
    comment: String
    dateOfBirth: LocalDate
    firstName: String!
    gender: GenderType
    groups(pageRequest: PageRequestInput): CustomerGroupPage
    id: UUID!
    lastName: String
    phoneNumber: String
    points: Int!
}

type CustomerAddress {
    baseAddress: String!
    door: String
    doorCode: String
    flatNumber: String
    floor: Int @deprecated(reason: "use floorString")
    floorString: String
}

type CustomerForCurrentDayWidget {
    averageCheck: BigDecimal!
    orderAmount: BigDecimal!
    orderCount: Int!
    points: Int!
    since: Instant
}

type CustomerForCurrentDayWidgetOutput {
    widget: CustomerForCurrentDayWidget!
}

type CustomerGroup {
    color: String!
    customers(pageRequest: PageRequestInput): CustomerPage
    customersCount: Int!
    description: String
    id: UUID!
    name: String!
    store: Store
}

type CustomerGroupPage implements Page {
    content: [CustomerGroup!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type CustomerGroupResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: CustomerGroup
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type CustomerOrder {
    discountAmount: BigDecimal!
    itemsCount: Int!
    orderAmount: BigDecimal!
    orderId: UUID!
    orderNumber: String!
    paySystemNames: String!
    paymentDate: Instant!
    revenue: BigDecimal!
    shift: Int!
}

type CustomerOrdersPage {
    content: [CustomerOrder!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type CustomerPage implements Page {
    content: [Customer!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type CustomerResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Customer
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type CustomerSnapshot {
    cardNumber: String
    dateOfBirth: LocalDate
    firstName: String
    id: UUID!
    lastName: String
    phoneNumber: String
}

type DailyLoyaltyAnalytics {
    date: LocalDate!
    loyaltyAnalytics: LoyaltyAnalytics!
}

"Timespan within day when discount is active"
type DailyPeriod {
    "Day of week for which the activity period is set"
    dayOfWeek: DayOfWeek!
    "Maximum time of day when discount is active"
    maxTime: LocalTime!
    "Minimal time of day when discount is active"
    minTime: LocalTime!
}

type DarkTask {
    accountId: UUID
    canceledAt: Instant
    closedAt: Instant
    createdAt: Instant
    doneAt: Instant
    employeeId: UUID
    id: UUID!
    inProgressedAt: Instant
    inWarehouseId: UUID
    kitchenWorkshopId: UUID
    outWarehouseId: UUID
    status: Status
    store: Store!
    taskItems: [TaskItem!]!
    taskNumber: Long
}

type DarkTaskPage implements Page {
    content: [DarkTask!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type DateRange {
    from: LocalDate
    to: LocalDate
}

type DebitLoyalty {
    active: Boolean!
    beginsAt: LocalDate
    customerGroups(pageRequest: PageRequestInput): CustomerGroupPage
    description: String
    endsAt: LocalDate
    id: UUID!
    image: Image
    maxPercentage: Int!
    name: String!
    pointPrice: BigDecimal!
    storeBindings: [LoyaltyStoreBinding!]!
}

type DebitLoyaltyPage implements Page {
    content: [DebitLoyalty!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type DebitLoyaltyResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: DebitLoyalty
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type DeclineSupportControlClaimResult {
    id: UUID!
}

type DeliveryApiKey {
    apiKey: UUID!
    deliveryCounterparty: DeliveryCounterparty!
    organizationId: UUID!
    secret: String!
    storeIds: [UUID!]!
}

"Delivery Counterparty"
type DeliveryCounterparty {
    "Description of the counterparty"
    description: String
    id: UUID!
    "Counterparty name"
    name: String!
}

"Shipping Information"
type DeliveryInfo {
    change: AmountData
    clientArrivementDate: Instant
    clientName: String
    "Comment"
    comment: String
    courierArrivementDate: Instant
    "Current stage of order"
    currentStage: OrderStage!
    "Shipping cost of the order"
    deliveryAmount: AmountData
    "Delivery Counterparty"
    deliveryCounterparty: DeliveryCounterparty
    """

    The time by which the order should be delivered in the yyyy-MM-dd'T'HH:mm:ss.SS'Z'format.
    If NULL, it will be delivered as soon as possible.
    """
    deliveryDate: Instant
    "Delivery end time. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    endOf: Instant
    "Delivery address"
    fullAddress: String
    nextStage: Stage
    "Number of guests for whom the order will be created"
    personCount: Int
    phoneNumber: String
    "The stages that the order went through"
    stages: [OrderStage!]
    "Delivery start time. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    startAt: Instant
    yandexPromos: [YandexPromo!]
}

"Demand Reset Password Response"
type DemandResetPasswordResponse {
    "Identity type, such as email or phone"
    identityType: IdentityType!
    "Demand Reset Password. Request ID"
    requestId: UUID!
}

type DemandResetPasswordResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: DemandResetPasswordResponse
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type Device {
    createdDate: LocalDate
    deviceType: DeviceType!
    deviceUniqueKey: String
    id: UUID!
    model: String
    name: String
}

type DevicePage implements Page {
    content: [Device!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type DeviceRestriction {
    allowed: Int!
    deviceType: TermsDeviceType!
}

type DeviceUsage {
    deviceType: DeviceType!
    used: Int!
}

"Discount data"
type Discount {
    "List of binding this discount has on catalog, sections and/or products"
    bindings: [DiscountBinding!]
    "Catalog ID"
    catalogId: UUID!
    "Short description"
    description: String
    "Type"
    discountType: DiscountType!
    "Quantity of items in cart needed for discount with `discountType == COUNTED` to be applied"
    freeQuantity: Int
    "Discount ID"
    id: UUID!
    image: Image
    "Is discount active"
    isActive: Boolean!
    "Should discount be applied automatically when an order where it's applicable is created"
    isAutomatic: Boolean!
    "Can discont be combined with other discounts"
    isCombined: Boolean!
    "Should percent be displayed alongside discount"
    isPercentShown: Boolean!
    "Should discount be visible to client"
    isShownToUser: Boolean!
    "Name"
    name: String!
    "Amount in percent"
    percent: BigDecimal
    "Period when discount is active"
    period: ActivityPeriod!
    "Store ID"
    storeId: UUID!
}

"Discounts data grouped by hour for the selected period"
type DiscountAnalyticsByHour {
    "hourly average check with discounts"
    averageHourlyCheck: BigDecimal!
    "hourly average discount amount"
    averageHourlyDiscountAmount: BigDecimal!
    "hourly average revenue for orders with discounts"
    averageHourlyRevenueWithDiscounts: BigDecimal!
    "hourly average revenue for orders without discounts"
    averageHourlyRevenueWithoutDiscounts: BigDecimal!
    "at which hour data has been collected"
    hour: Int!
    "hourly total used unique discounts"
    totalHourlyDiscountsCount: Int!
    "hourly total guests count with discounts"
    totalHourlyGuestsCount: Int!
}

"Discount analytics data for given date"
type DiscountAnalyticsChartReport {
    "average amount in check where discounts were used"
    averageCheck: BigDecimal!
    "date for which data has been collected"
    date: LocalDate!
    "daily amount of discounts"
    discountAmount: BigDecimal!
    "daily number of guests who used discounts"
    guestsCount: Int!
    "daily profit"
    revenue: BigDecimal! @deprecated(reason: "use revenueWithDiscounts and revenueWithoutDiscounts")
    "daily revenue for sold positions with discounts in all orders"
    revenueWithDiscounts: BigDecimal!
    "daily revenue for sold positions without discounts"
    revenueWithoutDiscounts: BigDecimal!
    "daily number of used distinct discounts"
    usedDiscountsCount: Int!
}

"Summary of discount data for given period"
type DiscountAnalyticsSummary {
    "average check with applied discounts"
    averageCheck: BigDecimal!
    "daily amount of discounts"
    discountAmount: BigDecimal!
    "daily number of guests who used discounts"
    guestsCount: Int!
    "daily profit"
    revenue: BigDecimal! @deprecated(reason: "use revenueWithDiscounts and revenueWithoutDiscounts")
    "daily revenue for sold positions with discounts in all orders"
    revenueWithDiscounts: BigDecimal!
    "daily revenue for sold positions without discounts"
    revenueWithoutDiscounts: BigDecimal!
    "daily number of used distinct discounts"
    usedDiscountsCount: Int!
}

"Binding of discount either to catalog, section or product"
type DiscountBinding {
    "Amount of items in cart, which belong to entity from this binding, for `discountType == COMBO` to be applied"
    amount: BigDecimal
    "ID of bound entity from catalog"
    entityId: UUID
    "Type of bound entity"
    entityType: BoundEntityType
    "Discount binding ID"
    id: UUID!
    "Applications of discount to stock units"
    stockUnitIds: [UUID!]
}

type DiscountProgram {
    automatic: Boolean!
    basis: DiscountBasis!
    combined: Boolean!
    dailyPeriods: [DailyPeriod!]
    id: UUID!
    percent: BigDecimal!
    promotionProgram: PromotionProgram!
}

type DiscountProgramResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: DiscountProgram
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type DiscountResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: DiscountV2
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

"Table of discount applications"
type DiscountTableViewRow {
    "Date-time of sale"
    appliedAt: LocalDateTime!
    "Amount of applied discount"
    discountPrice: AmountData!
    "Name of an item sold"
    itemName: String!
    "Store in which item was sold"
    storeName: String!
    "Sale price of a position in order"
    totalPrice: AmountData!
}

"Discount data"
type DiscountV2 {
    "discount based on order or order item"
    basis: DiscountBasis!
    "customer groups discount belongs to"
    customerGroups(pageRequest: PageRequestInput): CustomerGroupPage
    "Short description"
    description: String
    "Discount ID"
    id: UUID!
    "image"
    image: Image
    "Is discount active"
    isActive: Boolean!
    "Should discount be applied automatically when an order where it's applicable is created"
    isAutomatic: Boolean!
    "Can discont be combined with other discounts"
    isCombined: Boolean!
    "Should percent be displayed alongside discount"
    isPercentShown: Boolean!
    "Name"
    name: String!
    "Amount in percent"
    percent: BigDecimal!
    "Period when discount is active"
    period: ActivityPeriod!
    "old bindings now bounded to store"
    storeBindings: [LoyaltyStoreBinding!]!
}

type DiscountV2Page implements Page {
    content: [DiscountV2!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type DiscountsRevenue {
    discountMarginLoss: BigDecimal!
    revenueWithDiscounts: BigDecimal!
    revenueWithoutDiscounts: BigDecimal!
}

type DiscountsUsed {
    ordersWithDiscounts: Int!
    ordersWithoutDiscounts: Int!
}

"Document data"
type Document {
    "Creation date"
    creationDate: Instant
    "Execution date"
    date: Instant
    "Description"
    description: String
    docNumber: Long
    "Document ID"
    id: UUID
    "Organization that created the document"
    organization: Organization
    "ID of actual typed document (e.g. arrival document ID)"
    originalDocumentId: UUID
    "Status"
    status: StatusDocument
    "Type"
    typeDocument: TypeDocument
}

"Document item data"
type DocumentItem {
    "Amount of money transferred for this item"
    amount: Float
    "amount difference between fact and plan quantity"
    amountDelta: BigDecimal
    "total ARRIVAL and MOVE quantity of a corresponding document item since last inventory where warehouse TO is equal to warehouse where inventory is being processed"
    arrivalFromLastInventory: BigDecimal
    "Comment"
    comment: String
    convertableUnit: ConvertableUnit
    "Currency of amount literal code (e.g. RUB)"
    currency: String
    "Factual quantity of items"
    factQuantity: Float
    "id"
    id: UUID
    "Last inventory Date"
    lastInventoryDate: Instant
    lastInventoryDocumentId: UUID
    "Leftover on last inventory (fact quantity from last inventory)"
    leftoverOnLastInventory: BigDecimal
    "Name"
    name: String
    "Initially planned quantity of items"
    planQuantity: Float
    "quantity difference between fact and plan quantity"
    quantityDelta: BigDecimal
    resultLeavingItem: [ResultLeavingItem!]
    "total sold quantity of a corresponding stock unit since last inventory"
    soldFromLastInventory: BigDecimal
    "Stock unit"
    stockUnit: StockUnit
    "total LEAVING and MOVE quantity of a corresponding document item since last inventory where warehouse FROM is equal to warehouse where inventory is being processed"
    writtenOffFromLastInventory: BigDecimal
}

type DocumentPage implements Page {
    content: [Document!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Menu duplicating result"
type DuplicateMenuResponse {
    storesMenus: [StoreMenu!]!
}

"Employee (linking entity between account and organization)"
type Employee {
    "Employee's account"
    account: Account
    "ID of account, employeed user"
    accountId: UUID
    "Describes employee accessibility"
    active: Boolean!
    "Living address"
    address: String
    "Date of birth (ISO-8601)"
    dateOfBirth: Instant
    "Date of employment (ISO-8601)"
    dateOfEmployment: Instant
    "Invitation to organization for current employee"
    employeeInvitation: EmployeeInvitation
    "Employee alias name"
    firstName: String!
    "Employee ID"
    id: UUID!
    invitation: Invitation
    lastName: String!
    "Medical book expire date (ISO-8601)"
    medicalBookExpiresAt: Instant
    middleName: String
    "Organization, employer"
    organization: Organization!
    "ID of organization, employer"
    organizationId: UUID! @deprecated(reason: "use `organization` field")
    "Name of organization, employer"
    organizationName: String! @deprecated(reason: "use `organization` field")
    "Employee permissions"
    permissions: [Permission!]!
    "PIN code"
    pin: String
    "Encoded employee PIN code bcrypt"
    pinToken: String
    "СНИЛС"
    snils: String
    "Employee targeted permissions (access control list)"
    targetPermissions: [EmployeeTargetPermission!]!
    "Usergroup membership"
    userGroups: [EmployeeUserGroup!]!
    "ИНН"
    vatin: String
    "Contact email"
    workEmail: String!
    "Contact phone"
    workPhone: String
}

type EmployeeByPointTransaction {
    firstName: String!
    id: UUID!
    lastName: String!
    middleName: String
    roles: [RoleCode]!
}

type EmployeeCreated {
    employee: Employee!
}

"Private employee invitation"
type EmployeeInvitation {
    "Confirmation token for this invitation"
    confirmationToken: String!
    "Employee willing for employement"
    employee: Employee!
    "Invitation expire date (ISO-8601)"
    expiresAt: Instant!
    id: UUID!
    "Employee account login (email), used to send invitation"
    login: String
    "URL"
    url: String!
}

"Invited employee roles"
type EmployeeInvitationRole {
    role: String!
    roleCode: RoleCode!
    storeName: String
}

type EmployeePage implements Page {
    content: [Employee!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type EmployeeRemoved {
    id: UUID!
}

type EmployeeSubscription {
    employee: Employee!
    mutation: EmployeeSubscriptionType!
}

"Security targeted permission. Can allow access to entities by ID"
type EmployeeTargetPermission {
    "Action performed for targeted permission (e.g. **READ** or **WRITE**)"
    action: Action!
    "Target permission ID"
    id: UUID!
    "Scope of target permission (e.g. **STORE** or **CATALOG**)"
    scope: Scope!
    "Entity targets for this permission"
    targets: [UUID!]!
}

type EmployeeUpdated {
    employee: Employee!
}

"Employee's user group binding"
type EmployeeUserGroup {
    "Unique group code"
    code: RoleCode!
    "ID of this employee's user group binding"
    id: UUID!
    "User group name"
    name: String
    "ID of store in which user group is applied (null for admins)"
    storeId: UUID
    "User group ID"
    userGroupId: UUID!
}

type ExtendSupportControlClaimResult {
    id: UUID!
}

type ExternalImage {
    ratio: Float!
    scale: Scale!
    url: String!
}

type FiscalDocument implements KKTDocument {
    checksum: String
    client: Client
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int
    documentType: DocumentType
    electronically: Boolean
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String
    items: [ReceiptItemWrapper]
    ofd: Ofd
    ofdTicket: OfdTicket
    operator: Operator
    orderId: UUID
    organizationName: String
    organizationVatin: String
    payments: [Payment]
    registrationNumber: String
    roundTotal: Boolean
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
    taxSystem: TaxSystem
    type: FiscalReceiptType
}

type FrequentlyBoughtTogetherProducts {
    "CrossingPercent out of 100"
    crossingPercent: BigDecimal!
    "StockUnitName in crossing percent order descending"
    stockUnitName: String!
}

"A single goal"
type GoalItem {
    "Goal ID"
    id: UUID!
    "Attribute describing whether the goal is completed by user"
    isComplete: Boolean!
    "Name"
    name: String
}

"Group of associated goals"
type GoalSection {
    "List of goals in this group"
    goals: [GoalItem!]!
    "Goal group ID"
    id: UUID!
    "Name"
    name: String
}

"Action on notification that triggers GraphQL query or mutation"
type GraphQLNotificationAction {
    "Method name"
    methodName: String!
    "Method type (query or mutation)"
    methodType: GraphQLMethodType!
    "Optional parameters that need to be passed to GraphQL method"
    parameters: [GraphQLNotificationActionParameter!]
}

"Parameter to send in GraphQL query triggered by notification"
type GraphQLNotificationActionParameter {
    "Parameter path"
    path: String!
    "Parameter value as string"
    value: String!
}

type HourlyLoyaltyAnalytics {
    hour: Int!
    loyaltyAnalytics: LoyaltyAnalytics!
}

"Account identity. (different logins for same user)"
type Identity {
    "Is this identity confirmed and allowed for using"
    confirmed: Boolean! @deprecated(reason: "Do not use. Will be removed soon. Identity, if exists - is always confirmed")
    "Identity ID"
    id: UUID!
    "Identity type (email or phone)"
    identityType: IdentityType!
    "Identity value (e.g. **unknown@mail.dot**)"
    value: String!
}

type IdentityClaim {
    "Account id"
    accountId: UUID
    "Identity claim ID"
    id: UUID!
    "Claiming identity type"
    identityType: IdentityType!
    "Claiming identity value"
    value: String!
}

"Identity removed response payload"
type IdentityRemovedPayload {
    id: UUID!
}

type Image {
    "image extension (e.g. jpg, png...)"
    extension: String!
    "image id"
    id: UUID!
    "multiple image sizes with url to each image size"
    imageSizes: [ImageSize!]!
    "original file name"
    originalFileName: String!
}

type ImageSize {
    "image height"
    height: Int
    "url to specific image size"
    url: String
    "image width"
    width: Int
}

type ImagesWithSize {
    "image id"
    id: UUID!
    "array of urls to specific image"
    urls: [URL!]!
}

"Page of catalog subelements"
type InCatalogPage implements Page {
    content: [InCatalogResponse!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type Ingredient {
    "Quantity in specified units"
    quantity: BigDecimal!
    "Stock Unit Id"
    stockUnitId: UUID!
    "Measurement unit type"
    unitType: UnitType!
}

type IntegrationProperty {
    clientId: UUID!
    clientSecret: String!
    host: String!
    restaurantId: UUID!
}

"Inventory document data"
type InventoryDocument {
    "Creation date"
    creationDate: Instant
    "Execution date"
    date: Instant
    "Description"
    description: String
    "Number"
    docNumber: Long
    "Inventory items"
    documentItems: [DocumentItem!]
    "Warehouse of inventory"
    from: Warehouse
    "Inventory document ID"
    id: UUID
    "Organization that created the document"
    organization: Organization
    "Status"
    status: StatusDocument
    "Total document item's amount delta"
    totalAmountDelta: BigDecimal!
    type: InventoryType
    "Type"
    typeDocument: TypeDocument
}

type InventoryDocumentPage implements Page {
    content: [InventoryDocument!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type InventoryDocumentResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: InventoryDocument
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

"Employee invitation"
type Invitation {
    employeeId: UUID!
    employeeRoles: [EmployeeInvitationRole!]!
    id: UUID!
    organizationInfo: InvitationOrganizationInfo!
    organizationName: String @deprecated(reason: "use organizationInfo")
}

type InvitationOrganizationInfo {
    id: UUID!
    name: String
    shortId: String!
}

type IssueSupportControlClaimResult {
    supportControlClaimIds: [UUID!]!
}

type ItemBarcode {
    alignment: Aligment
    barcode: String
    barcodeType: BarcodeType
    scale: Int
}

type ItemText {
    alignment: Aligment
    fontDoubleHeight: Boolean
    fontDoubleWidth: Boolean
    fontNumber: Long
    linespacing: Long
    text: String
    wrap: TextWrap
}

type KKTDocumentUnionPage implements Page {
    content: [KKTDocumentUnion]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Kitchen workshop data"
type KitchenWorkshop {
    address: String
    autoConfirm: Boolean!
    "Creation date-time in system"
    createdAt: Instant
    "Kitchen workshop ID"
    id: UUID!
    "ID of warehouse which supplies items to kitchen workshop"
    inWarehouseId: UUID
    manualVerification: Boolean!
    name: String!
    "ID of organization kitchen workshop belongs to"
    organizationId: UUID!
    "ID of warehouse which stores items made in kitchen workshop"
    outWarehouseId: UUID
    "ID of store kitchen workshop serves"
    store: Store
    "techcards kitchen workshop can process"
    techCards: [TechCard!]!
}

type KitchenWorkshopPage implements Page {
    content: [KitchenWorkshop!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Arrival document data"
type LeavingByOrderDocument {
    "Creation date"
    creationDate: Instant
    "Execution date"
    date: Instant
    "Description"
    description: String
    "Number"
    docNumber: Long
    "Arrived items"
    documentItems: [DocumentItem!]
    "Arrival document ID"
    id: UUID
    "Supplier of arrival"
    order: Order
    "Organization that created the document"
    organization: Organization
    "Status"
    status: StatusDocument
    "Type"
    typeDocument: TypeDocument
    "Warehouse of arrival"
    warehouse: Warehouse
}

type LeavingByOrderDocumentPage implements Page {
    content: [LeavingByOrderDocument!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Leaving document data"
type LeavingDocument {
    "Creation date"
    creationDate: Instant
    "Execution date"
    date: Instant
    "Description"
    description: String
    "Number"
    docNumber: Long
    "Left items"
    documentItems: [DocumentItem!]
    "Warehouse of leaving"
    from: Warehouse
    "Leaving document ID"
    id: UUID
    "Organization that created the document"
    organization: Organization
    "Status"
    status: StatusDocument
    "Total document item's amount"
    totalAmount: BigDecimal!
    "Type"
    typeDocument: TypeDocument
}

type LeavingDocumentPage implements Page {
    content: [LeavingDocument!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type LeavingDocumentResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: LeavingDocument
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

"Light task data"
type LightTask {
    cancelled: Boolean
    "Light task ID"
    id: UUID!
    "ID of warehouse which supplies items for this task"
    inWarehouseId: UUID
    "ID of kitchen workshop this task has been assigned to"
    kitchenWorkshopId: UUID!
    "ID of order that spawned this task"
    orderId: UUID!
    "ID of warehouse which stores items made during this task"
    outWarehouseId: UUID
    status: Status
    "store this task is for"
    store: Store!
    "Items created with this task"
    taskItems: [TaskItem!]
}

"Lost password response"
type LostPasswordResponse {
    "Identity type, such as email or phone"
    identityType: IdentityType!
    "Lost password request ID"
    requestId: UUID!
}

type LoyaltyAnalytics {
    discountsUsed: DiscountsUsed!
    loyaltyUsed: LoyaltyUsed!
    revenueWithDiscounts: DiscountsRevenue!
}

type LoyaltyAnalyticsSummary {
    discountsUsed: Int!
    loyaltyUsed: Int!
    revenueWithDiscounts: BigDecimal!
}

type LoyaltyPointTransaction {
    beforePoints: Int!
    customer: CustomerSnapshot!
    date: Instant!
    id: UUID!
    loyalties: [LoyaltySnapshot]!
    orderId: UUID!
    organizationId: UUID!
    pointTransactionFact: PointTransactionFactCore!
    points: Int!
    storeId: UUID!
    terminalId: UUID!
}

"PointTransaction"
type LoyaltyPointTransactionPage implements Page {
    content: [LoyaltyPointTransaction]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type LoyaltyPointTransactionResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: LoyaltyPointTransaction
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type LoyaltyPoints {
    earn: Int
    spent: Int
    spentAmount: BigDecimal
}

type LoyaltySnapshot {
    id: UUID!
    loyaltyId: UUID!
    name: String!
    pointPrice: BigDecimal!
    points: Int!
    stockUnitIds: [UUID]
}

type LoyaltyStoreBinding {
    bindings: [CreditLoyaltyBinding!]
    storeId: UUID!
}

type LoyaltyUsed {
    ordersWithLoyalty: Int!
    ordersWithoutLoyalty: Int!
}

type ManualLoyaltyPointsModificationTransactionResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: ManualLoyaltyPointsTransaction
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

"Manual"
type ManualLoyaltyPointsTransaction {
    accountId: UUID!
    beforePoints: Int!
    comment: String
    customer: Customer
    customerId: UUID!
    date: Instant!
    id: UUID!
    organizationId: UUID!
    points: Int!
    type: LoyaltyPointsTransactionType!
}

"Measuring something"
type MeasureData {
    "Qty"
    quantity: BigDecimal!
    "Unit of measurement"
    unit: UnitType!
}

"Menu object"
type Menu {
    "amoumt of all menu items in all menu sections"
    countOfItems: MenuItemsAmount!
    "Total number of sections in menu"
    countOfSections: MenuItemsAmount!
    countOfStores: Long!
    "Number of subsections in menu"
    countOfSubSections: MenuItemsAmount!
    countOfTerminals: Long!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    "menu id"
    id: UUID!
    "amoumt of all menu items in all menu sections"
    menuItemsAmount: Long @deprecated(reason: "use countOfItems")
    "menu sections that current menu has inside"
    menuSections: [MenuSection!]
    "menu name"
    name: String!
    "Online menu for this pos menu"
    onlineMenu: OnlineMenu
    "organization to which the menu belongs"
    organization: Organization!
    "sort number"
    position: Int
    "store to which the menu belongs"
    storeId: UUID!
    "menu type"
    type: MenuType
}

type MenuElementsPage implements Page {
    "Menu elements"
    content: [MenuElement]!
    "Current page number"
    pageNumber: Int!
    "The number of items on that page"
    pageSize: Int!
    "The total amount of available items"
    total: Int!
    "Count of available pages"
    totalPages: Int!
}

"Menu item object"
type MenuItem {
    "is menu item active"
    active: Boolean!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    "menu item id"
    id: UUID!
    "menu item images"
    images: [Image]
    "Sale price"
    itemSalePrice: AmountData
    "menu section id"
    menuSectionId: UUID
    "menu item name"
    name: String!
    "Online menu section for this pos menu item"
    onlineMenuItem: OnlineMenuItem
    orderPosition: Float
    "menu item sort number"
    position: Int @deprecated(reason: "use orderPosition instead")
    "Sale price"
    salePrice: AmountData! @deprecated(reason: "sale price may be null if stock unit not exist for this item. use itemSalePrice")
    "stock unit of menu item"
    stockUnit: StockUnit
}

type MenuItemCreatedDto {
    "Created menu item"
    menuItem: MenuItem!
}

type MenuItemDeletedDto {
    "Deleted menu item ID"
    menuItemId: UUID!
}

type MenuItemResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: MenuItem
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type MenuItemUpdatedDto {
    "Updated menu item"
    menuItem: MenuItem!
}

type MenuItemsAmount {
    inactive: Long!
    total: Long!
}

type MenuPage implements Page {
    content: [Menu!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Menu section object"
type MenuSection {
    "is menu section active"
    active: Boolean!
    "color code of menu section"
    colorCode: String @deprecated(reason: "use colorSection")
    "colorSection enum"
    colorSection: ColorSection
    countOfItems: MenuItemsAmount!
    countOfSections: MenuItemsAmount!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    "depth level, if 0 then parent menu section"
    depthLevel: Long
    "menu section id"
    id: UUID!
    image: Image
    "is menu section parent"
    isParent: Boolean
    "labels of menu section"
    labels: [String!]
    "left margin in the sections nested set"
    leftMargin: Int
    "menu id"
    menuId: UUID
    "menu items of current menu section"
    menuItems: [MenuItem!]
    "nested menu sections"
    menuSections: [MenuSection!]
    "menu section name"
    name: String!
    "Online menu section for this pos menu section"
    onlineMenuSection: OnlineMenuSection
    orderPosition: Float
    "parent menu section id"
    parentSectionId: UUID
    position: Int @deprecated(reason: "use orderPosition instead")
    "right margin in the sections nested sets"
    rightMargin: Int
}

"menu section color"
type MenuSectionColor {
    "color code (e.g. `#FFAF8E`)"
    code: String!
    "color name"
    name: String
}

type MenuSectionCreatedDto {
    "Created menu section"
    menuSection: MenuSection!
}

type MenuSectionDeletedDto {
    "Menu ID of deleted section"
    menuId: UUID!
    "Deleted menu section ID"
    menuSectionId: UUID!
}

type MenuSectionResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: MenuSection
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type MenuSectionUpdatedDto {
    "Updated menu section"
    menuSection: MenuSection!
}

type MenuStructureResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Menu
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type ModifierGroup {
    active: Boolean!
    depthLevel: Int!
    entityId: UUID!
    entityName: String!
    entityType: ModifierEntityType!
    id: UUID!
    maxValue: Int!
    minValue: Int!
    modifiers: [Modifier!]!
    name: String!
    required: Boolean!
    sort: Int!
    stockUnitIds: [UUID!]!
    type: ModifierType!
}

type ModifierGroupOutput {
    active: Boolean
    id: UUID!
    maxValue: Int
    minValue: Int
    modifiers(pageRequest: PageRequestInput): ModifierPage!
    name: String
    products(pageRequest: PageRequestInput): ProductPage!
    required: Boolean
    sort: Int
    type: ModifierType
}

type ModifierGroupOutputPage implements Page {
    content: [ModifierGroupOutput!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ModifierGroupPage implements Page {
    content: [ModifierGroup!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ModifierGroupResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: ModifierGroupOutput
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type ModifierPage implements Page {
    content: [Modifier!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ModifiersReport {
    "categories chain: child category first"
    categories: [CategorySnapshot!]
    discount: BigDecimal!
    prime: BigDecimal!
    productName: String!
    productType: ProductType!
    profit: BigDecimal!
    revenue: BigDecimal!
    sales: BigDecimal!
    stockUnitId: UUID!
}

type ModifiersReportOutput {
    rows(pageRequest: PageRequestInput): ModifiersReportPage!
    total: ModifiersReportTotal!
}

type ModifiersReportPage {
    content: [ModifiersReport!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ModifiersReportTimeSeries {
    discount: BigDecimal!
    prime: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
    timestamp: Instant!
}

type ModifiersReportTimeSeriesOutput {
    elements: [ModifiersReportTimeSeries!]!
}

type ModifiersReportTotal {
    discount: BigDecimal!
    prime: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
}

type MonetizationOrder {
    accountingPeriod: DateRange
    amount: AmountData
    discount: AmountData
    id: UUID!
    items: [MonetizationOrderItem!]
    organizationId: UUID!
    totalAmount: AmountData
}

type MonetizationOrderItem {
    amount: AmountData
    description: String
    id: UUID!
    name: String
    price: AmountData
    quantity: Int
}

type MonetizationOrderResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: MonetizationOrder
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type MostPopularCategoriesWidgetOutput {
    elements: [MostPopularCategory!]!
}

type MostPopularCategory {
    id: UUID!
    name: String!
    profit: BigDecimal!
    quantity: BigDecimal!
    revenue: BigDecimal!
}

type MostPopularProduct {
    id: UUID!
    name: String!
    profit: BigDecimal!
    quantity: BigDecimal!
    revenue: BigDecimal!
    unitType: UnitType!
}

type MostPopularProductsWidgetOutput {
    elements: [MostPopularProduct!]!
}

"Move document data"
type MoveDocument {
    "Creation date"
    creationDate: Instant
    "Execution date"
    date: Instant
    "Description"
    description: String
    "Number"
    docNumber: Long
    "Moved items"
    documentItems: [DocumentItem!]
    "Source warehouse of moving"
    from: Warehouse
    "Moving document ID"
    id: UUID
    "Organization that created the document"
    organization: Organization
    "Status"
    status: StatusDocument
    "Target warehouse of moving"
    to: Warehouse
    "Total document item's amount"
    totalAmount: BigDecimal!
    "Type"
    typeDocument: TypeDocument
}

type MoveDocumentPage implements Page {
    content: [MoveDocument!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type MoveDocumentResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: MoveDocument
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type Mutation {
    "Accept employee invitation"
    acceptEmployeeInvitation(
        "Confirmation token"
        confirmationToken: String!,
        "Employee invitation ID"
        employeeInvitationId: UUID!
    ): MutationResult!
    "Accept invitation"
    acceptEmployeeInvite(
        "Validation token"
        token: String!
    ): AcceptEmployeeInviteResponse!
    "Accept organization invitation"
    acceptOrganizationInvitation(
        "Confirmation token"
        confirmationToken: String!,
        "Organization invitation ID"
        organizationInvitationId: UUID!
    ): Void
    "Terminal acquiring request, registering NEW binding between teminal and store ID, or obtaining already bound, returns NEW or EXISTING terminal ID"
    acquireTerminal(
        "Terminal hardware or software fingerprint, can be used later to receive same terminal instance."
        fingerprint: String!,
        "Store ID terminal linking with"
        storeId: UUID!
    ): TerminalAcquiringInfo! @deprecated(reason: "Use saveTerminalData & saveTerminalOrderSequence")
    "activate menu item"
    activateMenuItem(id: UUID!): Void
    "activate menu items"
    activateMenuItems(id: [UUID!]!): Void
    addBarCodeToStockUnit(barcode: String!, stockUnitId: UUID!): Void @deprecated(reason: "use barcodes in stockUnitInput for create or update stockUnit with barcodes")
    addMenuStructure(
        "category of the menu to which you want to add structure"
        categoryId: UUID,
        struct: MenuStructureInput
    ): MenuStructureResult
    addModifiers(modifierGroupId: UUID!, modifiers: [CreateModifierInput!]!): ModifierGroupResult!
    addStockUnitModifier(modifier: StockUnitModifierInput!, modifierGroupId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    addStockUnitModifiers(modifierGroupId: UUID!, modifiers: [StockUnitModifierInput!]!): MutationResultMultiple! @deprecated(reason: "use modifierGroupUpdate")
    addTextModifier(modifier: TextModifierInput!, modifierGroupId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    addTextModifiers(modifierGroupId: UUID!, modifiers: [TextModifierInput!]!): MutationResultMultiple! @deprecated(reason: "use modifierGroupUpdate")
    "Create a payment to link a bank card to a user's account. The card will be linked after payment is made."
    addUserPaymentCard(
        "Redirect URL from paymo wiget from unsuccesseful payment"
        failRedirectUrl: String,
        "Redirect URL from paymo wiget from successeful payment"
        successRedirectUrl: String!
    ): PaymoPayment!
    "Confirm order. The order will sent to the kitchen."
    approveOrder(
        orderId: UUID!,
        "Mapping order items to kitchen workshops"
        orderItemsMap: [OrderItemsToKitchenInput!]
    ): Void
    "Perform second auth phase. Returns JWT pair if success"
    auth(
        "Seccond-phase auth input"
        login: LoginInput!
    ): AuthData!
    bindPaySystem(paySystemId: UUID!, storeId: UUID!): Void
    cancelAddons(addonRequests: [CancelAddonInput!]!): SubscriberResult
    "Cancel order"
    cancelOrder(orderId: UUID!, reason: String): Void
    "Update account password"
    changeAccountPassword(
        "Change password data"
        changePasswordInput: ChangePasswordInput!
    ): Void
    changeLostPassword(
        "Confirmation code"
        code: String!,
        "New account password"
        password: String!,
        "Lost password request ID"
        requestId: UUID!
    ): Void
    changeMenuItemPosition(positionUpdate: MenuItemPositionUpdateInput!): MenuItemResult!
    changeMenuSectionPosition(positionUpdate: MenuSectionPositionUpdateInput!): MenuSectionResult!
    changeTerminalsForOrders(terminalFromId: UUID!, terminalToId: UUID!): Void
    "Claim identity for current account"
    claimIdentity(
        "Identity value, e.g. EMAIL or PHONE number"
        value: String!
    ): UUID!
    "Mark that user passed nomia welcome tutorial"
    completeOnboarding: Void @deprecated(reason: "Use account update")
    "Confirm an existing arrival document"
    confirmArrivalDocument(
        "Arrival document ID"
        arrivalDocumentId: UUID!,
        warehouseId: UUID!
    ): MutationResult!
    "Confirm an existing inventory document"
    confirmInventoryDocument(
        "Inventory document id"
        inventoryDocumentId: UUID!,
        warehouseId: UUID!
    ): MutationResult!
    "Confirm an existing leaving document"
    confirmLeavingDocument(
        "Leaving document id"
        leavingDocumentId: UUID!,
        warehouseId: UUID!
    ): MutationResult!
    "Confirm an existing move document"
    confirmMoveDocument(
        fromWarehouseId: UUID!,
        "Move document id"
        moveDocumentId: UUID!,
        toWarehouseId: UUID!
    ): MutationResult! @deprecated(reason: "use confirmMoveDocumentV2")
    "Confirm an existing move document"
    confirmMoveDocumentV2(
        "Move document id"
        moveDocumentId: UUID!
    ): MoveDocumentResult!
    "Confirm an existing return document"
    confirmReturnDocument(
        "Return document id"
        returnDocumentId: UUID!,
        warehouseId: UUID!
    ): MutationResult!
    "Confirm supportControl claim by password."
    confirmSupportControlClaim(confirmClaim: ConfirmSupportControlClaimInput!): ConfirmSupportControlClaimResult
    "Confirm tech support claim by password"
    confirmTechSupportClaim(
        "Issued claim id"
        claimId: UUID!,
        "Password confirmation"
        password: String!
    ): Void @deprecated(reason: "use confirmSupportControlClaim")
    "Request a token for access to an external device or application"
    createApplicationToken(posInfo: ApplicationInfoInput!): String!
    createApplicationTokenV2(posInfo: ApplicationInfoInputV2!): String!
    "create arrival document."
    createArrivalDocument(
        "Arrival document data"
        arrivalDocumentCreateInput: ArrivalDocumentCreateInput!
    ): MutationResult
    createBonusProgram(program: BonusProgramCreateInput!): BonusProgramResult
    "create catalog"
    createCatalog(catalog: CatalogCreateInput!): UUID! @deprecated(reason: "use createCatalogV2")
    "create section"
    createCatalogSection(section: CatalogSectionCreateInput!): UUID! @deprecated(reason: "use createCatalogSectionV2")
    "create catalog section"
    createCatalogSectionV2(catalogSection: CatalogSectionCreateInputV2!): CatalogSectionResult
    "create catalog"
    createCatalogV2(catalog: CatalogCreateInput!): CatalogResult
    createCreditLoyalty(creditLoyalty: CreditLoyaltyCreateInput!): CreditLoyaltyResult @deprecated(reason: "use createBonusProgram")
    createCustomer(customer: CustomerCreateInput!): CustomerResult
    createCustomerGroup(customerGroup: CustomerGroupCreateInput!): CustomerGroupResult
    "Create new dark task"
    createDarkTask(
        "Created dark task data"
        darkTaskInput: DarkTaskInput!
    ): MutationResult
    createDebitLoyalty(debitLoyalty: DebitLoyaltyCreateInput!): DebitLoyaltyResult @deprecated(reason: "use createBonusProgram")
    "create a new discount"
    createDiscount(
        "created discount data"
        discountCreateInput: DiscountCreateInput!
    ): MutationResult!
    createDiscountProgram(program: DiscountProgramCreateInput!): DiscountProgramResult
    "create a new discount"
    createDiscountV2(
        "created discount data"
        discountCreateInput: DiscountCreateInputV2!
    ): DiscountResult
    "Create new employee"
    createEmployee(
        "Employee data"
        createEmployeeInput: CreateEmployeeInput!
    ): UUID!
    "Create employee invitation"
    createEmployeeInvitation(
        "Invitation data"
        createEmployeeInvitationInput: CreateEmployeeInvitationInput!
    ): UUID!
    "create  inventory document."
    createInventoryDocument(
        "created inventory document data"
        inventoryDocumentCreateInput: InventoryDocumentCreateInput!
    ): MutationResult
    "Create new kitchen workshop"
    createKitchenWorkshop(
        "created kitchen workshop data"
        kitchenWorkshopCreateInput: KitchenWorkshopCreateInput
    ): UUID
    "create leaving document."
    createLeavingDocument(
        "created LeavingDocument data"
        leavingDocumentCreateInput: LeavingDocumentCreateInput!
    ): MutationResult
    "Create new light task"
    createLightTask(
        "Create light task data"
        input: LightTaskInput!
    ): UUID!
    "create new menu"
    createMenu(menuCreateInput: MenuCreateInput!): UUID!
    createMenuFromYandexMenu(menuId: UUID!): UUID!
    "create new menu item. Needed existing menu section and stock unit"
    createMenuItem(menuItem: MenuItemInput!): UUID!
    "create multiple menu items at once"
    createMenuItemsList(menuItems: [MenuItemInput!]!): [MutationResult!]!
    "create new menu section. Could be new parent menu section or new nested menu section"
    createMenuSection(menuSectionCreateInput: MenuSectionCreateInput!): MutationResult! @deprecated(reason: "use createMenuSectionV2")
    "create new menu section with SectionColor. Could be new parent menu section or new nested menu section"
    createMenuSectionV2(menuSectionCreateInput: MenuSectionCreateInput!): MenuSectionResult
    createMenuStructure(struct: MenuStructureInput): MenuStructureResult
    createModifierGroup(entityId: UUID!, entityType: ModifierEntityType!, sort: Int): MutationResult! @deprecated(reason: "use modifierGroupCreate")
    "create move document."
    createMoveDocument(
        "created MoveDocument data"
        moveDocumentCreateInput: MoveDocumentCreateInput!
    ): MutationResult
    "Create order"
    createOrder(orderCreateInput: OrderCreateInput!, orderPayments: [OrderPaymentInput!]): MutationResult!
    "Create payment by order"
    createOrderPayment(orderPayment: OrderPaymentInput!): UUID!
    "Create new organization"
    createOrganization(
        "Organization data"
        createOrganizationInput: CreateOrganizationInput!
    ): UUID!
    "Create new organization invitation"
    createOrganizationInvitation(
        "Organization invitation data"
        createOrganizationInvitationInput: CreateOrganizationInvitationInput!
    ): UUID!
    "Create new organization"
    createOrganizationV2(
        "Organization data"
        createOrganizationInput: CreateOrganizationInput!
    ): OrganizationResult
    "Create a payment system for the store"
    createPaySystem(paySystemCreateInput: PaySystemCreateInput!, storeId: UUID!): UUID! @deprecated(reason: "Use createPaymentSystem")
    createPaymentSystem(paymentSystemCreateInput: PaymentSystemCreateInput!): PaymentSystemResult!
    "create or update cooking process. If `processCreateInput.id` is null, creates new process, else updates an existing one"
    createProcess(
        "created process data"
        processCreateInput: ProcessCreateInput!
    ): UUID
    "create product and stockUnits with techCard"
    createProduct(product: ProductCreateInput!): MutationResult!
    "create product"
    createProductV2(product: ProductCreateInput!): ProductResult
    "create  return document."
    createReturnDocument(
        "created ReturnDocument data"
        returnDocumentCreateInput: ReturnDocumentCreateInput!
    ): MutationResult
    "Create store"
    createStore(storeCreateInput: StoreCreateInput!): UUID! @deprecated(reason: "Use createStoreV2")
    "Create a ghost store"
    createStoreGhost(parentStoreId: UUID!): UUID!
    createStoreV2(storeCreateInput: StoreCreateInput!): StoreResult
    createSubscribers: Void
    "create supplier"
    createSupplier(
        "created supplier data"
        supplierCreateInput: SupplierCreateInput!
    ): UUID
    "create supplier with response as SupplierResult"
    createSupplierV2(input: SupplierCreateInput!): SupplierResult!
    "Create multiple table bookings"
    createTableBookings(inputs: [TableBookingInput!]!): [CreateTableBookingResult]
    createTaxProfile(taxProfileCreateInput: TaxProfileCreateInput!): UUID! @deprecated(reason: "No longer supported")
    "Create a terminal for the store"
    createTerminal(terminalCreateInput: TerminalCreateInput!): UUID! @deprecated(reason: "Use saveTerminalData & saveTerminalOrderSequence")
    "create warehouse."
    createWarehouse(
        "created warehouse data"
        warehouseCreateInput: WarehouseCreateInput!
    ): UUID
    "create warehouseV2"
    createWarehouseV2(input: WarehouseCreateInputV2!): WarehouseResult
    createYandexMenuFromMenu(menuId: UUID!): UUID!
    "deactivate menu item"
    deactivateMenuItem(id: UUID!): Void
    "deactivate menu items"
    deactivateMenuItems(id: [UUID!]!): Void
    "Decline revoked support control claim"
    declineSupportControlClaim(claimId: UUID!): DeclineSupportControlClaimResult!
    "Delete an existing arrival document"
    deleteArrivalDocument(
        "Arrival document ID"
        arrivalDocumentId: UUID!
    ): MutationResult!
    "delete catalog with sections, products and stockUnits"
    deleteCatalog(
        "Catalog ID"
        id: UUID!
    ): MutationResult
    "delete section with subsections? products and stockUnits"
    deleteCatalogSection(
        "Section ID"
        id: UUID!
    ): MutationResult!
    deleteCreditLoyalty(creditLoyaltyId: UUID!): CreditLoyaltyResult @deprecated(reason: "use deletePromotionProgram")
    deleteCustomer(id: UUID!): CustomerResult
    deleteCustomerGroup(id: UUID!): CustomerGroupResult
    deleteDebitLoyalty(debitLoyaltyId: UUID!): DebitLoyaltyResult @deprecated(reason: "use deletePromotionProgram")
    "Delete an existing discount"
    deleteDiscount(
        "Discount ID"
        id: UUID!
    ): MutationResult!
    "Delete an existing discount"
    deleteDiscountV2(
        "Discount ID"
        id: UUID!
    ): DiscountResult
    "Delete an existing inventory document"
    deleteInventoryDocument(
        "Inventory document id"
        inventoryDocumentId: UUID!
    ): MutationResult!
    deleteKitchenWorkshop(id: UUID!): Void
    "Delete an existing leaving document"
    deleteLeavingDocument(
        "Leaving document id"
        leavingDocumentId: UUID!
    ): MutationResult!
    "Delete light task"
    deleteLightTask(
        "Light task ID"
        id: UUID!
    ): Void
    "delete menu by id"
    deleteMenu(id: UUID!): MutationResult!
    "delete menu item"
    deleteMenuItem(id: UUID!): Void
    "delete menu section"
    deleteMenuSection(id: UUID!): MutationResult!
    deleteModifierGroup(modifierGroupId: UUID!): MutationResult!
    "Delete an existing move document"
    deleteMoveDocument(
        "Move document id"
        moveDocumentId: UUID!
    ): MutationResult!
    "Delete payment system"
    deletePaySystem(paySystemId: UUID!, storeId: UUID!): Void @deprecated(reason: "Use deletePaymentSystem")
    "Delete payment system"
    deletePaymentSystem(id: UUID!): PaymentSystemResult
    "delete product, stockUnits and techCards"
    deleteProduct(
        "Product ID"
        id: UUID!
    ): MutationResult!
    deletePromotionProgram(id: UUID): PromotionProgramResult
    "Delete an existing return document"
    deleteReturnDocument(
        "Return document id"
        returnDocumentId: UUID!
    ): MutationResult!
    "Delete store"
    deleteStore(storeId: UUID!): Void
    "Remove ghost store"
    deleteStoreGhost(storeGhostId: UUID!): Void
    "Delete store"
    deleteStoreV2(storeId: UUID!): StoreResult
    "Delete an existing supplier"
    deleteSupplier(
        "Supplier ID"
        supplierId: UUID!
    ): UUID
    "Delete terminal"
    deleteTerminal(terminalId: UUID!): Void
    "Delete the user's bank card"
    deleteUserPaymentCard(cardId: UUID!): MutationResult!
    "Delete an existing warehouse"
    deleteWarehouse(
        "Warehouse ID"
        warehouseId: UUID!
    ): UUID
    "Deliver the order. The order has been delivered to the client"
    deliverOrder(orderId: UUID!): Void
    "Demand Reset Password"
    demandResetPassword(
        "Account login"
        login: String!
    ): DemandResetPasswordResult
    disableModifierGroup(entityId: UUID!, modifierGroupId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    "duplicate existing arrival document"
    duplicateArrivalDocument(documentId: UUID!): ArrivalDocumentResult
    "duplicate existing inventory document"
    duplicateInventoryDocument(documentId: UUID!): InventoryDocumentResult
    "duplicate existing leaving document"
    duplicateLeavingDocument(documentId: UUID!): LeavingDocumentResult
    "duplicate menu for multiple store ids"
    duplicateMenu(menuDuplicateInput: MenuDuplicateInput): DuplicateMenuResponse!
    "duplicate existing move document"
    duplicateMoveDocument(documentId: UUID!): MoveDocumentResult
    "duplicate product"
    duplicateProduct(productId: UUID!): ProductResult
    enableModifierGroup(entityId: UUID!, modifierGroupId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    "Extend support control claims expiration datetime"
    extendSupportControlClaim(claimId: UUID!, extendDuration: Int): ExtendSupportControlClaimResult!
    "Mark all goals in group with `groupId` as done"
    finalizeGoalsByGroupId(
        "Optional feedback text to submit on goal group completion"
        feedbackText: String,
        "ID of group which goals are to be marked as done"
        groupId: UUID!
    ): Void
    fixStockUnitPrimePriceInAnalytics(dateFrom: LocalDateTime!, dateTo: LocalDateTime!, newPrimePrice: BigDecimal!, stockUnitId: UUID!): Void
    "Grant rights for the specified entity for employee"
    grantEmployeeTargetPermission(
        "Action allowed to perform on entity"
        action: Action!,
        "ID of employee who is granted rights"
        employeeId: UUID!,
        "ID of entity"
        entityId: UUID!,
        "Scope of entity"
        scope: Scope!
    ): Void
    "Hides all notifications which aren't already hidden"
    hideAllNotifications: Void
    hideNotification(notificationId: UUID!): Void
    "Confirm identity with code"
    identityClaimConfirm(
        "Confirmation code, received by user"
        code: String!,
        "TemporaryToken ID"
        temporaryTokenId: UUID!
    ): Void
    "Remove identity claim by ID"
    identityClaimRemove(
        "IdentityClaim ID"
        id: UUID!
    ): Void
    "Send identity confirmation code, returns TemporaryToken ID, which will be required for confirmation"
    identityClaimSendConfirmation(identityClaimId: UUID!): UUID!
    "Remove identity by ID"
    identityRemove(
        "Identity ID"
        id: UUID!
    ): IdentityRemovedPayload
    initAuth(login: String!, type: SignInType): SignInResponseData
    "Creates invitation. If sendTo specified - sends invitation link to this destination"
    inviteEmployee(
        "Employee id"
        employeeId: UUID!,
        sendTo: String
    ): SendEmployeeInviteResponse!
    "Creating support control claims for organization employees"
    issueSupportControlClaim(issueClaim: IssueSupportControlClaimInput!): IssueSupportControlClaimResult!
    "Issue new tech support claim; Issue will be created for organization passed in request header. Returns organization Id"
    issueTechSupportClaim: UUID! @deprecated(reason: "use issueSupportControlClaim")
    "Perform second auth phase. Returns JWT pair if success"
    login(
        "Seccond-phase auth input"
        login: LoginInput!
    ): String! @deprecated(reason: "Mutation & return value is deprecated, use mutation 'auth' instead")
    "Request password recovery"
    lostPassword(
        "Account login"
        login: String!
    ): LostPasswordResponse! @deprecated(reason: "use demandResetPassword")
    manualAddAddons(addonRequests: [AddAddonInput!]!): SubscriberResult
    manualChangeServicePlan(servicePlanId: UUID!): SubscriberResult
    manualModifyLoyaltyPoints(manualLoyaltyPointsModificationInput: ManualLoyaltyPointsModificationInput!): ManualLoyaltyPointsModificationTransactionResult @deprecated(reason: "use manualModifyPoints")
    manualModifyPoints(input: ManualModifyPointsInput!): Void
    markNotificationAsShown(notificationId: UUID!): Void
    modifierGroupAttachProducts(modifierGroupId: UUID!, productIds: [UUID!]!): ModifierGroupResult!
    modifierGroupCreate(modifierGroup: CreateModifierGroupInput!): ModifierGroupResult!
    modifierGroupDetachProducts(modifierGroupId: UUID!, productIds: [UUID!]!): ModifierGroupResult!
    modifierGroupUpdate(modifierGroup: UpdateModifierGroupInput!): ModifierGroupResult!
    "move product"
    moveProduct(newSectionId: UUID, targetProductId: UUID!): ProductResult
    "move catalog section"
    moveSection(newSectionId: UUID, targetSectionId: UUID!): CatalogSectionResult
    "Set online menu item image"
    onlineMenuItemSetImage(input: OnlineMenuItemSetImageInput!): OnlineMenuItemSetImageResponse!
    "Set online menu section image"
    onlineMenuSectionSetImage(input: OnlineMenuSectionSetImageInput!): OnlineMenuSectionSetImageResponse!
    "Change online menu active state"
    onlineMenuSetActiveState(input: OnlineMenuSetActiveStateInput!): OnlineMenuSetActiveStateResponse!
    orderAddon(addonRequests: [OrderAddonInput!]!): MonetizationOrderResult
    orderRecurringBill(billId: UUID!): MonetizationOrderResult
    orderServicePlan(servicePlanId: UUID!): MonetizationOrderResult
    payOrder(orderId: UUID!): PaymentInfoResult
    "Pay a payment by order"
    payOrderPayment(orderPaymentId: UUID!): Void
    "Receive the order by the courier. The courier with the order will be on the way to the client."
    pickupOrder(orderId: UUID!): Void
    pinModifier(modifierGroupId: UUID!, modifierId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    "Reads all notifications which aren't already read"
    readAllNotifications: Void
    readNotification(notificationId: UUID!): Void
    "Refresh JWT pair, RefreshToken header must be passed in request with actual refresh token;"
    refresh: AuthData! @deprecated(reason: "Use refreshTokens")
    "Refresh JWT pair;"
    refreshTokens(refreshToken: String!): AuthData!
    refundOrder(orderId: UUID!): Void
    refundOrderPayment(orderPaymentId: UUID!): Void
    "Reject an existing arrival document"
    rejectArrivalDocument(
        "Arrival document ID"
        arrivalDocumentId: UUID!
    ): MutationResult!
    "Reject an existing inventory document"
    rejectInventoryDocument(
        "Inventory document id"
        inventoryDocumentId: UUID!
    ): MutationResult!
    "Reject an existing leaving document"
    rejectLeavingDocument(
        "Leaving document id"
        leavingDocumentId: UUID!
    ): MutationResult!
    "Reject an existing move document"
    rejectMoveDocument(
        "Move document id"
        moveDocumentId: UUID!
    ): MutationResult!
    "Reject an existing return document"
    rejectReturnDocument(
        "Return document id"
        returnDocumentId: UUID!
    ): MutationResult!
    removeDevice(deviceId: UUID!): Void
    "Remove existing employee"
    removeEmployee(
        "Employee ID to be removed"
        employeeId: UUID!
    ): Void
    removeModifier(modifierGroupId: UUID!, modifierId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    removeModifiers(modifierGroupId: UUID!, modifierIds: [UUID!]!): ModifierGroupResult!
    "Remove existing organization invitation"
    removeOrganizationInvitation(
        "Organization invitation ID to be removed"
        organizationInvitationId: UUID!
    ): Void
    resetPassword(
        "Confirmation code"
        code: String!,
        "Lost password request ID"
        requestId: UUID!
    ): ResetPasswordResult
    "revoke api key"
    revokeDeliveryApiKey(apiKey: UUID!): Void
    "Cancel employee invitation"
    revokeEmployeeInvite(
        "Employee id"
        employeeId: UUID!
    ): RevokeEmployeeInviteResponse!
    "Revoke rights for the specified entity for employee"
    revokeEmployeeTargetPermission(
        "Action disallowed to perform on entity"
        action: Action!,
        "ID of employee who is revoked rights"
        employeeId: UUID!,
        "ID of entity"
        entityId: UUID!,
        "Scope of entity"
        scope: Scope!
    ): Void
    "Revoke issued support control claim"
    revokeSupportControlClaim(claimId: UUID!): RevokeSupportControlClaimResult!
    "Revoke issued tech support claim"
    revokeTechSupportClaim(claimId: UUID!): Void @deprecated(reason: "use revokeSupportControlClaim")
    saveKKTDocuments(kktDocuments: KKTDocumentsInput!): SaveKKTDocumentsPayload!
    """

    "
    save mapped menu from Yandex.Eats
    """
    saveMappedYandexEatsMenu(storeId: UUID!, yandexEatsUrl: String!, yandexMenuCategories: [YandexMenuCategoryInput!]!): UUID!
    saveStoreReceiptSettings(settings: SaveStoreReceiptSettingsInput!): SaveStoreReceiptSettingsResult
    saveStoreTableGroups(storeTableGroupsInput: StoreTableGroupsInput!): SaveStoreTableGroupsResult
    "Terminal save/update, returns NEW or EXISTING terminal ID"
    saveTerminal(terminalInput: TerminalInput!): UUID! @deprecated(reason: "Use saveTerminalData & saveTerminalOrderSequence")
    "Save/update terminal"
    saveTerminalData(terminalInput: TerminalInputData!): TerminalSaveResult!
    "Save terminal last order sequence number"
    saveTerminalOrderSequence(fingerprint: String, orderSequence: Long!, storeId: UUID!): TerminalSaveOrderSequenceResult!
    "Send employee invitation"
    sendEmployeeInvitation(
        "Invitation id"
        employeeInvitationId: UUID!,
        sendTo: String!
    ): Void
    setOrderReady(orderId: UUID!): Void
    "Assign a courier to the order. The order will wait until the courier arrives and picks up the order."
    setOrderWaitingCourier(orderId: UUID!): Void
    "The courier has reached the client's address and is waiting for him"
    setOrderWaitingGuest(orderId: UUID!): Void
    "Change subscriptions to store rates"
    setStoreSubscriptions(
        bindNewCard: Boolean,
        "Redirect URL from paymo wiget from unsuccesseful payment"
        failRedirectUrl: String,
        "Rate options that will be enabled for the store. All other subscriptions will be disabled"
        servicePlanOptionsId: [UUID!]!,
        storeId: UUID!,
        "Redirect URL from paymo wiget from successeful payment"
        successRedirectUrl: String!,
        "User payment card ID"
        userCardId: UUID
    ): PaymoPayment
    "Set specified tech cards to be supported by this kitchen workshop"
    setTechCardsToKitchenWorkshop(
        "Kitchen workshop ID"
        kitchenWorkshopId: UUID!,
        "IDs of tech cards added to this kitchen workshop's supported tech cards list"
        techCardList: [UUID!]!
    ): Void
    "Specify the user's banned card as the default card"
    setUserPaymentCardAsDefault(cardId: UUID!): MutationResult!
    """

    Create sign-in request for two-phase authorization
    Returned value describes identity type (email, phone, etc.) and password-based authorization availability for current request
    If SignInType not specified, default type will be 'ERP'
    """
    signIn(login: String!, type: SignInType): SignInResponse! @deprecated(reason: "Mutation is deprecated, use mutation 'signInV2' instead")
    """

    Create sign-in request for two-phase authorization
    Returned value describes identity type (email, phone, etc.) and password-based authorization availability for current request
    If SignInType not specified, default type will be 'ERP'
    The return value might be null if the login check fails
    """
    signInV2(login: String!, type: SignInType): SignInResponse
    sortModifierGroups(entityId: UUID!, entityType: ModifierEntityType!, sortedModifierGroups: [ModifierGroupSortInput!]!): MutationResult! @deprecated(reason: "No longer supported")
    sortModifiers(modifierGroupId: UUID!, sortedModifiers: [ModifierSortInput!]!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    spendLoyaltyPoints(order: UploadOrderInput): LoyaltyPointTransactionResult @deprecated(reason: "use spendPointsForOrder")
    spendPointsForOrder(input: SpendOrderPointsInput!): PointsForOrder
    unpinModifier(modifierGroupId: UUID!, modifierId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    unreadNotification(notificationId: UUID!): Void
    "Update account info"
    updateAccount(
        "Account data"
        accountInput: AccountInput!
    ): Void
    "update arrival document."
    updateArrivalDocument(
        "Arrival document data"
        arrivalDocumentUpdateInput: ArrivalDocumentUpdateInput!
    ): MutationResult
    updateBonusProgram(program: BonusProgramUpdateInput!): BonusProgramResult
    updateCachedCategories(orgId: UUID!): [CachedCategory!]
    updateCachedCategoriesAndProducts(orgId: UUID!): [CachedCategory!]
    "update catalog"
    updateCatalog(catalog: CatalogUpdateInput!): Void @deprecated(reason: "use updateCatalogV2")
    "update section"
    updateCatalogSection(section: CatalogSectionUpdateInput!): Void @deprecated(reason: "use updateCatalogSectionV2")
    "update catalog section"
    updateCatalogSectionV2(catalogSection: CatalogSectionUpdateInputV2!): CatalogSectionResult
    "update catalog"
    updateCatalogV2(catalog: CatalogUpdateInput!): CatalogResult
    updateCreditLoyalty(creditLoyalty: CreditLoyaltyUpdateInput!): CreditLoyaltyResult @deprecated(reason: "use updateBonusProgram")
    updateCustomer(customer: CustomerUpdateInput!): CustomerResult
    updateCustomerGroup(customerGroup: CustomerGroupUpdateInput!): CustomerGroupResult
    updateCustomerV2(customer: CustomerUpdateInputV2!): CustomerResult
    "Update processing status of existing dark task"
    updateDarkTaskStatus(
        "Dark task ID"
        darkTaskId: UUID!,
        "New processing status for dark task"
        status: Status!
    ): MutationResult
    updateDebitLoyalty(debitLoyalty: DebitLoyaltyUpdateInput!): DebitLoyaltyResult @deprecated(reason: "use updateBonusProgram")
    "Update an existing discount"
    updateDiscount(
        "Updated discount data including its ID"
        discountUpdateInput: DiscountUpdateInput!
    ): MutationResult!
    updateDiscountProgram(program: DiscountProgramPatchUpdateRequest!): DiscountProgramResult
    "Update an existing discount"
    updateDiscountV2(
        "Updated discount data including its ID"
        discountUpdateInput: DiscountUpdateInputV2!
    ): DiscountResult
    "Update existing employee"
    updateEmployee(
        "Employee data"
        updateEmployeeInput: UpdateEmployeeInput!
    ): Void
    "Updates employee invitation & refreshes confirmation token automatically"
    updateEmployeeInvitation(
        "Invitation data"
        updateEmployeeInvitationInput: UpdateEmployeeInvitationInput!
    ): Void
    "Update employee pin code. Generates random employee pin"
    updateEmployeePinCode(employeeId: UUID!): UpdateEmployeePinCodeResponse!
    "update inventory document."
    updateInventoryDocument(
        "updated inventory document data"
        inventoryDocumentUpdateInput: InventoryDocumentUpdateInput!
    ): MutationResult
    "Update an existing kitchen workshop"
    updateKitchenWorkshop(
        "Updated kitchen workshop data"
        kitchenWorkshopUpdateInput: KitchenWorkshopUpdateInput
    ): Void
    "update leaving document."
    updateLeavingDocument(
        "updated LeavingDocument data"
        leavingDocumentUpdateInput: LeavingDocumentUpdateInput!
    ): MutationResult
    "Update processing status of existing light task"
    updateLightTaskStatus(
        "Light task ID"
        lightTaskId: UUID!,
        "New processing status for light task"
        status: Status!
    ): Void
    "update menu by id"
    updateMenu(menuUpdateInput: MenuUpdateInput!): Void
    "update menu item"
    updateMenuItem(menuItem: MenuItemInput!): Void
    "update multiple menu items at once"
    updateMenuItemsList(menuItems: [MenuItemInput!]!): [MutationResult!]!
    "update menu section"
    updateMenuSection(menuSectionUpdateInput: MenuSectionUpdateInput!): MutationResult! @deprecated(reason: "use updateMenuSectionV2")
    "update menu section with ColorSection"
    updateMenuSectionV2(menuSectionUpdateInput: MenuSectionUpdateInput!): MenuSectionResult
    updateMenuSectionV2Patch(menuSectionUpdateInput: MenuSectionPatchUpdateInput!): MenuSectionResult
    "update menu sections list"
    updateMenuSectionsList(menuSectionsUpdateInputList: [MenuSectionUpdateInput]!): [MutationResult!]!
    updateModifier(modifierGroupId: UUID!, modifierId: UUID!, name: String, pinned: Boolean, sort: Int): ModifierGroupResult!
    updateModifierGroup(modifierGroup: ModifierGroupInput!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    updateModifierGroupMaxValue(maxValue: Int!, modifierGroupId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    updateModifierGroupMinValue(minValue: Int!, modifierGroupId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    updateModifierGroupType(modifierGroupId: UUID!, type: ModifierType!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    "update move document."
    updateMoveDocument(
        "updated MoveDocument data"
        moveDocumentUpdateInput: MoveDocumentUpdateInput!
    ): MutationResult
    "Update existing organization"
    updateOrganization(
        "Organization data"
        updateOrganizationInput: UpdateOrganizationInput!
    ): Void
    "Update existing organization invitation"
    updateOrganizationInvitation(
        "Organization invitation data"
        updateOrganizationInvitationInput: UpdateOrganizationInvitationInput!
    ): Void
    "Update existing organization"
    updateOrganizationV2(
        "Organization data"
        updateOrganizationInput: UpdateOrganizationInput!
    ): OrganizationResult
    "Update payment system"
    updatePaySystem(paySystemUpdateInput: PaySystemUpdateInput!, storeId: UUID!): Void @deprecated(reason: "Use updatePaymentSystem")
    "Patch Update payment system"
    updatePaymentSystem(input: PaymentSystemUpdateInput!): PaymentSystemResult
    "create or update cooking process. If `processCreateInput.id` is null, creates new process, else updates an existing one"
    updateProcess(
        "updated process data"
        processUpdateInput: ProcessUpdateInput!
    ): Void
    "update product and stockUnits with techCard"
    updateProduct(product: ProductUpdateInput!): MutationResult!
    "update product"
    updateProductV2(product: ProductUpdateInput!): ProductResult
    updateProductV3(product: ProductPatchUpdateInput!): ProductResult
    "update return document."
    updateReturnDocument(
        "updated ReturnDocument data"
        returnDocumentUpdateInput: ReturnDocumentUpdateInput!
    ): MutationResult
    updateStockUnitModifier(modifier: StockUnitModifierUpdateInput!, modifierGroupId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    "full patch update store"
    updateStore(input: StoreUpdateInput!): StoreResult
    "Refresh store ghost"
    updateStoreGhost(storeGhostUpdateInput: StoreGhostUpdateInput!): Void
    "Update store information"
    updateStoreInfo(storeInfoUpdateInput: StoreInfoUpdateInput!): Void @deprecated(reason: "Use updateStore")
    "Update store information"
    updateStoreInfoV2(storeInfoUpdateInput: StoreInfoUpdateInput!): StoreResult @deprecated(reason: "Use updateStore")
    updateStoreInfoV3(storeInfoUpdateInput: StoreInfoUpdateInputV3!): StoreResult @deprecated(reason: "Use updateStore")
    "Update store requisites"
    updateStoreRequisites(storeRequisitesUpdateInput: StoreRequisitesUpdateInput!): Void @deprecated(reason: "Use updateStore")
    "Update store requisites"
    updateStoreRequisitesV2(storeRequisitesUpdateInput: StoreRequisitesUpdateInput!): StoreResult @deprecated(reason: "Use updateStore")
    "update supplier"
    updateSupplier(
        "updated supplier data"
        supplierUpdateInput: SupplierUpdateInput!
    ): Void
    "update supplier with response as SupplierResult"
    updateSupplierV2(input: SupplierUpdateInputV2!): SupplierResult!
    "Update multiple table bookings"
    updateTableBookings(inputs: [UpdateTableBookingInput!]!): [UpdateTableBookingResult]
    updateTaxProfile(taxProfileUpdateInput: TaxProfileUpdateInput!): Void @deprecated(reason: "No longer supported")
    "Update terminal"
    updateTerminal(terminalUpdateInput: TerminalUpdateInput!): Void @deprecated(reason: "Use saveTerminalData & saveTerminalOrderSequence")
    updateTextModifier(modifier: TextModifierUpdateInput!, modifierGroupId: UUID!): MutationResult! @deprecated(reason: "use modifierGroupUpdate")
    updateUIState(key: String!, uiState: String): UiStateResult
    "update warehouse."
    updateWarehouse(
        "updated warehouse data"
        warehouseUpdateInput: WarehouseUpdateInput!
    ): Void
    updateWarehouseV2(input: WarehouseUpdateInputV2): WarehouseResult
    uploadImages(images: [ImageInput!]!): UploadImageResponse!
    uploadOrders(orderPackInput: [OrderPackInput!]!): Void @deprecated(reason: "Use uploadOrdersV2")
    "Upload orders"
    uploadOrdersV2(input: UploadOrdersInput!): Void
    "get api key for yandex eats"
    yandexEatsAuthCredentials(storeId: UUID!): DeliveryApiKey!
}

"Result of a transactional mutation"
type MutationResult {
    "ID of the mutated entity"
    entityId: UUID!
    "Error message in case of failure"
    errorMessage: String
    "Result status of the transaction"
    result: TransactionResult!
}

type MutationResultMultiple {
    entityIds: [UUID]!
    "Error message in case of failure"
    errorMessage: String
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID!
}

"Button that appears on notification"
type NotificationButton {
    "Optional action performed on clicking the button"
    action: NotificationAction
    "Flag whether this button should be highlighted"
    isHighlighted: Boolean!
    "Label to show on button"
    label: String!
}

type Ofd {
    dns: String
    host: String
    name: String
    port: Int
    vatin: String
}

type OfdTicket {
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    fiscalSign: String
}

"Online menu. This is partially public api, so only limited data is present."
type OnlineMenu {
    active: Boolean
    id: UUID!
    name: String!
    orderDiscounts: [DiscountV2!]!
    sections: [OnlineMenuSection!]!
    shortId: String!
    storeInfo: OnlineMenuStoreInfo!
}

"Online menu item"
type OnlineMenuItem {
    discount: OnlineMenuItemDiscount
    imageId: UUID
    imageUrl: String
    menuItemId: UUID!
    name: String!
    position: Long!
    price: AmountData!
}

"Discount information for an item"
type OnlineMenuItemDiscount {
    discountAmount: AmountData!
    discountedPrice: AmountData!
}

type OnlineMenuItemSetImageResponse {
    imageId: UUID
}

"Online menu section"
type OnlineMenuSection {
    imageId: UUID
    imageUrl: String
    items: [OnlineMenuItem!]!
    itemsCount: Long!
    menuSectionId: UUID!
    name: String!
    position: Long!
    sections: [OnlineMenuSection!]!
}

type OnlineMenuSectionSetImageResponse {
    imageId: UUID
}

type OnlineMenuSetActiveStateResponse {
    onlineMenu: OnlineMenu!
}

"Online menu store representation"
type OnlineMenuStoreInfo {
    address: String
    name: String!
}

type Operator {
    name: String
    vatin: String
}

"Order"
type Order {
    amount: AmountData!
    "Sign of a closed order"
    canceled: Boolean!
    "Comment"
    comment: String
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    customer: CustomerSnapshot
    "Date of last payment. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    dateLastPayedDate: Instant
    "Delivery data"
    deliveryInfo: DeliveryInfo
    "Total amount of the discount"
    discountAmount: AmountData
    discounts: [AppliedOrderDiscount!]
    fiscalStatus: FiscalStatus
    "Id of the order"
    id: UUID!
    "Total amount of the discount by item discounts"
    itemDiscount: AmountData
    "List of order items"
    items: [OrderItem!]!
    labels: [OrderLabel]
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    lastModifiedDate: Instant
    loyaltyPoints: LoyaltyPoints
    "Total amount of the discount by order discounts"
    orderDiscount: AmountData
    "Order number"
    orderNumber: String!
    orderStatus: OrderState
    owner: SnapshotOrderEmployee
    "Sign of a paid order"
    payed: Boolean!
    "Payments on demand"
    payments: [OrderPayment!]
    "Reason of cancelation"
    reasonCanceled: String
    "refunded"
    refunded: Boolean
    salePrice: AmountData @deprecated(reason: "unused")
    "Shift id"
    shiftId: UUID
    shiftNumber: Int
    "Order status"
    status: OrderStatus! @deprecated(reason: "user orderStatus")
    store: Store
    terminal: Terminal
    "The total cost of the order"
    totalAmount: AmountData!
    "Order type"
    type: OrderType!
    "Date of last payment. Format yyyy-MM-dd HH:mm:ss"
    zonedDateLastPayedDate: LocalDateTime
}

type OrderByPointTransaction {
    amount: BigDecimal!
    id: UUID!
    orderNumber: String!
}

"Order created event"
type OrderCreatedEvent {
    "Created order"
    order: Order!
}

"Order deleted event"
type OrderDeletedEvent {
    "Deleted order ID"
    orderId: UUID!
}

"Item by order"
type OrderItem {
    amount: AmountData!
    "Discounts applied to the item"
    appliedDiscounts: [AppliedDiscount!]
    appliedModifiers: [AppliedModifier!]!
    barcode: String
    "Additional comment"
    comment: String
    "Course of serving the position to the guest"
    course: Int
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    "Discount amount"
    discountAmount: AmountData!
    "The number of the guest to whom the product (s) will be served by position"
    guest: Int
    "The numbers of the guests to whom the product (s) will be served by position"
    guestsNumbers: [Int!] @deprecated(reason: "use guest")
    "Id of position"
    id: UUID!
    images: [Image!]
    "Kitchen Workshops from tech card"
    kitchenWorkshopsId: [UUID!]
    "Product name by position"
    name: String!
    positionTypeCode: PositionTypeCode
    "Purchase value of position"
    primePrice: AmountData!
    "Number of products"
    quantity: MeasureData!
    "Market value of a position"
    salePrice: AmountData!
    sno: Sno
    "Position status"
    status: OrderItemStatus!
    "Id stock unit"
    stockUnitId: UUID!
    techCardId: UUID
    total: OrderItemTotalAmount!
    totalAmount: AmountData @deprecated(reason: "unused")
    vatType: VatType
    weighable: Boolean
}

type OrderItemTotalAmount {
    amount: AmountData!
    discount: AmountData!
    result: AmountData!
}

type OrderLabel {
    key: String!
    value: String!
}

type OrderPage implements Page {
    content: [Order!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Payment by order"
type OrderPayment {
    "Amount of payment"
    amount: AmountData!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant
    id: UUID!
    "Payment system by which the payment was created"
    paySystem: PaySystem!
    """

    Time when the payment was paid
    Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'
    """
    payedDate: Instant
    "Payment status"
    status: PaymentStatus!
}

"Order stage"
type OrderStage {
    "Duration of stage. ISO 8601 format: P (n) Y (n) M (n) DT (n) H (n) M (n) S"
    duration: String!
    "Stage end time. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    endOf: Instant
    "Stage id"
    id: UUID!
    "Stage name"
    name: Stage!
    "Stage start time. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    startAt: Instant!
}

type OrderTypeSpecificGravity {
    averageCheck: BigDecimal!
    averageCheckPercentOutOfTotal: Int!
    name: String!
    profit: BigDecimal!
    profitPercentOutOfTotal: Int!
    revenue: BigDecimal!
    revenuePercentOutOfTotal: Int!
    totalChecks: BigDecimal!
    totalChecksPercentOutOfTotal: Int!
    totalGuests: BigDecimal!
    totalGuestsPercentOutOfTotal: Int!
}

type OrderTypeWidgetOutput {
    elements: [OrderTypeSpecificGravity!]!
}

"Order updated event"
type OrderUpdatedEvent {
    "Updated order"
    order: Order!
}

type OrderWidget {
    averageCheck: BigDecimal!
    itemsCount: Int!
    orderAmount: BigDecimal!
    orderCount: Int!
    revenue: BigDecimal!
}

type OrderWidgetOutput {
    widget: OrderWidget!
}

type OrdersReport {
    currency: String
    date: Instant!
    fiscalStatus: FiscalStatus
    guestsCount: Int
    incomeAmount: BigDecimal!
    itemsCount: Int
    orderAmount: BigDecimal!
    orderId: UUID!
    orderNumber: String!
    paySystemNames: String
    paymentsAmount: BigDecimal!
    shift: Int
    status: OrderState
    taxAmount: BigDecimal!
}

type OrdersReportOutput {
    rows(pageRequest: PageRequestInput, sort: [OrdersReportSort!]): OrdersReportPage!
    total: OrdersReportTotal!
}

type OrdersReportPage {
    content: [OrdersReport!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type OrdersReportTimeSeries {
    averageCheck: BigDecimal!
    guestsCount: Int!
    itemsCount: Int!
    ordersCount: Int!
    profit: BigDecimal!
    revenue: BigDecimal!
    tax: BigDecimal!
    timestamp: Instant!
}

type OrdersReportTimeSeriesOutput {
    elements: [OrdersReportTimeSeries!]!
}

type OrdersReportTotal {
    guestsCount: Int!
    incomeAmount: BigDecimal!
    itemsCount: Int!
    ordersAmount: BigDecimal!
    ordersCount: Int!
    paymentsAmount: BigDecimal!
    taxAmount: BigDecimal!
}

"Organization"
type Organization {
    "Describes organization accessibility"
    active: Boolean
    "IDs of employees of this organization"
    employeeIds: [UUID!]
    "Organization ID"
    id: UUID!
    "Organization name"
    name: String
    settings: OrganizationSettings
    shortOrgId: String
}

"Bulk invitation"
type OrganizationInvitation {
    "Describes invitation accessibility"
    active: Boolean!
    "Confirmation token for this invitation"
    confirmationToken: String!
    "Invitation ID"
    id: UUID!
    "Simple invitation name"
    name: String!
    "Organization-employer"
    organization: Organization!
}

type OrganizationPage implements Page {
    content: [Organization!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type OrganizationPaymentsExistOutput {
    hasPayments: Boolean!
}

type OrganizationResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Organization
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

"Counterapty"
type OrganizationSearchDTO {
    "Counterapty inn"
    inn: String
    "Counterapty kpp"
    kpp: String
    ogrn: String
    okpo: String
    "Counterapty owner"
    owner: String
    "Counterapty physical address"
    physicalAddress: String
    registrationDate: LocalDate
    "Counterapty short name"
    shortName: String
}

"List of counterparties belongs request"
type OrganizationSearchResponse {
    organizationSearchDTOList: [OrganizationSearchDTO]!
}

type OrganizationSettings {
    currencyUnit: String!
}

"Get all information for provided organizationId. Which warehouses, catalogs, stores organization has"
type Overview {
    "all catalogs"
    catalogs: [Catalog!]!
    menus: [Menu!]!
    "all stores"
    stores: [Store!]!
    "all warehouses"
    warehouses: [Warehouse!]!
}

"Payment system"
type PaySystem {
    "Sign of disconnection of the payment system"
    active: Boolean!
    "Date of creation of this payment system"
    createdDate: Instant! @deprecated(reason: "not used")
    "Pay system icon type"
    icon: PaySystemIcon
    iconId: UUID @deprecated(reason: "use icon with enum")
    "Payment system id"
    id: UUID!
    "Payment system name"
    name: String!
    "Sequential number of the payment system in the list of payment systems"
    position: Int @deprecated(reason: "PaySystems are sorted within Store")
    stores: [Store!]!
    "Payment system type"
    type: PaySystemType!
}

"PaySystemAnalytics"
type PaySystemAnalytics {
    "Percent out of total from all payed orders"
    amount: BigDecimal!
    "PaySystem name"
    paySystemName: String!
}

type PaySystemCreatedEvent {
    paySystem: PaySystem!
}

type PaySystemRemovedEvent {
    paySystemId: UUID!
}

type PaySystemReport {
    averageCheck: BigDecimal!
    guestsCount: Int!
    ordersQuantity: Int!
    paySystemId: UUID!
    paySystemName: String!
    revenue: BigDecimal!
}

type PaySystemReportOutput {
    rows(pageRequest: PageRequestInput, sort: [PaySystemReportSort!]): PaySystemReportPage!
    total: PaySystemReportTotal!
}

type PaySystemReportPage implements Page {
    content: [PaySystemReport!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type PaySystemReportTimeSeries {
    guestsCount: Int!
    ordersCount: Int!
    revenue: BigDecimal!
    timestamp: Instant!
}

type PaySystemReportTimeSeriesOutput {
    elements: [PaySystemReportTimeSeries!]!
}

type PaySystemReportTotal {
    averageCheck: BigDecimal!
    guestsCount: Int!
    ordersQuantity: Int!
    revenue: BigDecimal!
}

type PaySystemUpdatedEvent {
    paySystem: PaySystem!
}

type Payment {
    sum: BigDecimal
    type: PaymentType
}

type PaymentCardNotBoundNotification {
    buttons: [NotificationButton!]
    createdDate: Instant
    id: UUID
    message: String
    type: NotificationType
}

type PaymentInfoResponse {
    details: String
    errorCode: String
    message: String
    paymentId: UUID!
    paymentUrl: String
    status: String
    success: Boolean
}

type PaymentInfoResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: PaymentInfoResponse
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type PaymentInvoiceCreatedNotification {
    createdDate: Instant
    id: UUID
    message: String
    type: NotificationType
}

"Payment system"
type PaymentSystem {
    "Sign of disconnection of the payment system"
    active: Boolean!
    hasStores: Boolean!
    "Pay system icon type"
    icon: PaySystemIcon
    "Payment system id"
    id: UUID!
    "Payment system name"
    name: String!
    "Sequential number of the payment system in the list of payment systems"
    stores: [Store!]!
    "Payment system type"
    type: PaySystemType!
}

type PaymentSystemPage implements Page {
    content: [PaymentSystem!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type PaymentSystemPercentOutOfTotal {
    averageCheck: BigDecimal!
    id: UUID!
    name: String!
    profit: BigDecimal!
    revenue: BigDecimal!
    revenuePercentOutOfTotal: Float!
    totalChecks: BigDecimal!
    totalChecksPercentOutOfTotal: Float!
    totalGuests: BigDecimal!
    totalGuestsPercentOutOfTotal: Float!
    type: String!
}

type PaymentSystemResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: PaymentSystem
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type PaymentSystemWidgetOutput {
    elements: [PaymentSystemPercentOutOfTotal!]!
}

"Invoice for payment in the Paymo system"
type PaymoPayment {
    "Cost"
    amount: AmountData!
    "Account Description"
    description: String
    "Payment Id"
    id: UUID!
    "The time until which the bill can be paid. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    lifeTime: Instant
    "Date of invoice payment. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    paymentDate: Instant
    "Account number"
    paymentNumber: String!
    "Account status"
    status: PaymentStatus!
    "Payment URL"
    url: String
}

type PaymoPaymentPage implements Page {
    content: [PaymoPayment!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Security permission"
type Permission {
    "Action performed for scope (e.g. **READ** or **WRITE**)"
    action: Action!
    "Permissions ID"
    id: UUID!
    "Permission simple name"
    name: String
    "Security scope (e.g. **ANALYTICS**)"
    scope: Scope!
}

type PointPrice {
    monetary: Int!
    points: Int!
}

type PointTransactionManual {
    comment: String
    customerId: UUID!
    dateOfTransaction: Instant
    employee: EmployeeByPointTransaction
    pointsAfterTransaction: Int!
    pointsBeforeTransaction: Int!
    pointsTransaction: Int!
    status: StatusPointTransaction!
    type: PointTransactionType!
}

type PointTransactionOrder {
    customerId: UUID!
    dateOfTransaction: Instant
    employee: EmployeeByPointTransaction
    order: OrderByPointTransaction
    pointsAfterTransaction: Int!
    pointsBeforeTransaction: Int!
    pointsTransaction: Int!
    status: StatusPointTransaction!
    storeId: UUID!
    terminalId: UUID
    type: PointTransactionType!
}

type PointTransactionPage implements Page {
    content: [PointTransaction!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type PointsForOrder {
    earn: Int
    spend: Int
}

"Popular product which most sales quantity for the selected period"
type PopularProduct {
    "name of the product"
    name: String!
    "product profit for the selected period"
    profit: BigDecimal!
    "margin on product sales for the selected period"
    profitPercent: Int!
    "product sales quantity for the selected period"
    quantity: BigDecimal!
    "product revenue for the selected period"
    revenue: BigDecimal!
}

type Position {
    amount: BigDecimal
    code: String
    name: String
    price: BigDecimal
    quantity: BigDecimal
    tax: TaxType
    type: ReceiptPositionType
    unit: PositionUnitType
}

"Position type with source location"
type PositionType {
    "Position type code"
    code: PositionTypeCode
    "Source ID"
    entityId: UUID
    "Source where position type has been got"
    entityType: CatalogEntityType
}

"Cooking process data"
type Process {
    "Process ID"
    id: UUID!
    "Name"
    name: String!
    "Organization which created this process"
    organization: UUID!
}

"Process item data"
type ProcessItem {
    "Percent of change in quantity during this process"
    percent: Int
    "Cooking process"
    process: Process
}

"Product output data"
type Product {
    "Catalog which the product belongs to"
    catalog: Catalog!
    "Product id"
    id: UUID!
    isSemiproduct: Boolean!
    "attachedModifierGroups(text: String, type: ModifierType, pageRequest: PageRequestInput):  ModifierGroupOutputPage"
    modifierGroupWhereUsedAsModifier(pageRequest: PageRequestInput): ModifierGroupOutputPage
    modifierGroups: [ModifierGroup!]! @deprecated(reason: "No longer supported")
    "Product name"
    name: String!
    "Section which the product belongs to"
    section: CatalogSection
    "list of product stockUnits"
    stockUnits: [StockUnit!]!
    "Type of product"
    type: ProductType
}

"Page of products"
type ProductPage implements Page {
    content: [Product!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ProductResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Product
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type ProductsReport {
    "categories chain: child category first"
    categories: [CategorySnapshot!]
    discount: BigDecimal!
    prime: BigDecimal!
    productId: UUID!
    productName: String!
    productType: ProductType!
    profit: BigDecimal!
    revenue: BigDecimal!
    sales: BigDecimal!
    stockUnitId: UUID!
    unitType: UnitType!
}

type ProductsReportLinkedProducts {
    "categories chain: child category first"
    categories: [CategorySnapshot!]
    discount: BigDecimal!
    prime: BigDecimal!
    productName: String!
    productType: ProductType!
    profit: BigDecimal!
    revenue: BigDecimal!
    sales: BigDecimal!
    stockUnitId: UUID!
    unitType: UnitType!
}

type ProductsReportLinkedProductsOutput {
    rows(pageRequest: PageRequestInput): ProductsReportLinkedProductsPage!
    total: ProductsReportLinkedProductsTotal!
}

type ProductsReportLinkedProductsPage {
    content: [ProductsReportLinkedProducts!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ProductsReportLinkedProductsTimeSeries {
    discount: BigDecimal!
    prime: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
    timestamp: Instant!
}

type ProductsReportLinkedProductsTimeSeriesOutput {
    elements: [ProductsReportLinkedProductsTimeSeries!]!
}

type ProductsReportLinkedProductsTotal {
    discount: BigDecimal!
    prime: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
}

type ProductsReportOutput {
    rows(pageRequest: PageRequestInput, sort: [ProductReportSort!]): ProductsReportPage!
    total: ProductsReportTotal!
}

type ProductsReportPage {
    content: [ProductsReport!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ProductsReportProductModifiers {
    "categories chain: child category first"
    categories: [CategorySnapshot!]
    discount: BigDecimal!
    prime: BigDecimal!
    productName: String!
    productType: ProductType!
    profit: BigDecimal!
    revenue: BigDecimal!
    sales: BigDecimal!
    stockUnitId: UUID!
    unitType: UnitType!
}

type ProductsReportProductModifiersOutput {
    rows(pageRequest: PageRequestInput): ProductsReportProductModifiersPage!
    total: ProductsReportProductModifiersTotal!
}

type ProductsReportProductModifiersPage {
    content: [ProductsReportProductModifiers!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ProductsReportProductModifiersTimeSeries {
    discount: BigDecimal!
    prime: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
    timestamp: Instant!
}

type ProductsReportProductModifiersTimeSeriesOutput {
    elements: [ProductsReportProductModifiersTimeSeries!]!
}

type ProductsReportProductModifiersTotal {
    discount: BigDecimal!
    prime: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
}

type ProductsReportTimeSeries {
    discount: BigDecimal!
    prime: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
    timestamp: Instant!
}

type ProductsReportTimeSeriesOutput {
    elements: [ProductsReportTimeSeries!]!
}

type ProductsReportTotal {
    discount: BigDecimal!
    prime: BigDecimal!
    profit: BigDecimal!
    revenue: BigDecimal!
    sales: Int!
}

type ProductsWithIngredientsXlsOutput {
    url: String!
}

type ProductsWithoutIngredientsXlsOutput {
    url: String!
}

type PromotionProgram {
    active: Boolean!
    beginsAt: LocalDate
    categoryIds: Selection!
    customerGroupIds: Selection!
    description: String
    endsAt: LocalDate
    id: UUID!
    imageId: UUID
    name: String!
    promotionType: PromotionType!
    "POS only field for SKU and discount mappings"
    resultSkuIds: Selection!
    stockUnitIds: Selection!
    storeIds: Selection!
}

type PromotionProgramPage implements Page {
    content: [PromotionProgramsUnion!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type PromotionProgramResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: PromotionProgram
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type Query {
    "Get popular products (which is also called `ABC report`) ordered by `revenue` descending for the selected period"
    abcReportPageable(filter: AbcReportPageableFilterInput!, pageRequest: PageRequestInput!): [ABCReport!]!
    abcReportV2(input: AbcReportInput!): AbcReportOutput!
    abcReportsExist(
        "IDs of stores to filter"
        storeIds: [UUID!]
    ): Boolean!
    "Get account by ID"
    account(id: UUID!): Account!
    activeAccountNotifications: [AccountNotification]!
    "For clients side. Get active tech support claims issued for current client"
    activeTechSupportClaims: [TechSupportClaim]! @deprecated(reason: "No longer supported")
    addon(addonId: UUID!): Addon!
    addons(pageRequest: PageRequestInput): AddonPage!
    "Get all employees for current application token store"
    allApplicationUserEmployees: [Employee!]!
    "Get all arrival documents for organization"
    allArrivalDocuments(
        "Minimal date from which the documents are selected"
        dateFrom: Instant,
        "Maximum date to which the documents are selected"
        dateTo: Instant,
        "Page number"
        page: Int!,
        "Words and phrases to search in descriptions of the selected documents"
        search: String,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): [ArrivalDocument!]! @deprecated(reason: "use allArrivalDocumentsPageable")
    "sort fields: [supplier, to, organization, docNumber, date, creationDate,status]"
    allArrivalDocumentsPageable(filter: DocumentFilterInput!, pageRequest: PageRequestInput!): ArrivalDocumentPage!
    allArrivalDocumentsPageableV2(filter: DocumentFilterInputV2, pageRequest: PageRequestInput, sort: [AllArrivalDocumentsPageableV2Sort!]): ArrivalDocumentPage!
    "Get all available payment systems for the organization. OrganizationId is taken from the header"
    allAvailablePaySystem: [PaySystem!]!
    "Get all existing tariffs"
    allAvailableServicePlans: [ServicePlan!]!
    """

    Get page of products by filter
    sort fields: [name]
    """
    allCatalogProductsPageable(
        "Filter object"
        filter: ProductFilterInput!,
        "Page request"
        pageRequest: PageRequestInput!
    ): ProductPage!
    "Get colors directory"
    allCatalogSectionColors: [CatalogSectionColor!]!
    "Get all sections by catalog id"
    allCatalogSections(
        "Catalog ID"
        catalogId: UUID!
    ): [CatalogSection]! @deprecated(reason: "use allCatalogSectionsPageable")
    """

    Get page of catalog sections by filter
    sort fields: [name, leftMargin, sort]
    """
    allCatalogSectionsPageable(
        "Filter object"
        filter: CatalogSectionFilterInput!,
        "Page requeset"
        pageRequest: PageRequestInput!
    ): CatalogSectionPage!
    "Get all catalogs from current organization"
    allCatalogs: [Catalog!]! @deprecated(reason: "At this moment organization can have only one catalog; use 'catalog' api call")
    allDarkTasks(page: Int!, size: Int!, sortField: String, sortOrder: String, statuses: [Status!]): [DarkTask!]! @deprecated(reason: "Use darkTasksByFilterPageable")
    "Get all documents for organization"
    allDocuments(
        "Minimal date from which the documents are selected"
        dateFrom: Instant,
        "Maximum date to which the documents are selected"
        dateTo: Instant,
        "Page number"
        page: Int!,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String,
        "Statuses one of which selected documents should have"
        statuses: [StatusDocument!]
    ): [Document!]! @deprecated(reason: "use allDocumentsPageable")
    "sort fields: [supplier, to, organization, docNumber, date, creationDate,status]"
    allDocumentsPageable(filter: AbstractDocumentFilterInput!, pageRequest: PageRequestInput!): DocumentPage!
    "Get all employees for current organization"
    allEmployees(activeFilter: Boolean, nameFilter: String, page: Int!, size: Int!, sortField: String, sortOrder: String): [Employee!]! @deprecated(reason: "use allEmployeesPageable")
    "sort fields: [account organization dateOfBirth dateOfEmployment address firstName middleName lastName createdDate lastModifiedDate]"
    allEmployeesPageable(filter: EmployeeFilterInput!, pageRequest: PageRequestInput!): EmployeePage!
    "Get all goals for organization grouped into sections"
    allGoals: [GoalSection!]!
    """

    Returns all catalog elements by filter with parent elements tree
    sort fields: [name]
    """
    allInCatalogPageable(
        "Filter for catalog elements"
        filter: InCatalogFilterInput!,
        "Page request"
        pageRequest: PageRequestInput
    ): InCatalogPage!
    "Get all inventory documents for organization"
    allInventoryDocuments(
        "Minimal date from which the documents are selected"
        dateFrom: Instant,
        "Maximum date to which the documents are selected"
        dateTo: Instant,
        "Page number"
        page: Int!,
        "Words and phrases to search in descriptions of the selected documents"
        search: String,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): [InventoryDocument!]! @deprecated(reason: "use allInventoryDocumentsPageable")
    "sort fields: [supplier, to, organization, docNumber, date, creationDate,status]"
    allInventoryDocumentsPageable(filter: DocumentFilterInput!, pageRequest: PageRequestInput!): InventoryDocumentPage!
    allInventoryDocumentsPageableV2(filter: InventoryDocumentFilterInputV2, pageRequest: PageRequestInput, sort: [AllInventoryDocumentsPageableV2Sort]): InventoryDocumentPage!
    "Get all kitchen workshops for organization"
    allKitchenWorkshops(
        "Page number"
        page: Int!,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String
    ): [KitchenWorkshop!]! @deprecated(reason: "use allKitchenWorkshopsPageable")
    "sort fields: [name, address, storeId, inWarehouseId, outWarehouseId, createdAt]"
    allKitchenWorkshopsPageable(pageRequest: PageRequestInput): KitchenWorkshopPage!
    allLeavingByOrderDocumentsPageable(filter: DocumentFilterInput!, pageRequest: PageRequestInput!): LeavingByOrderDocumentPage!
    "Get all leaving documents for organization"
    allLeavingDocuments(
        "Minimal date from which the documents are selected"
        dateFrom: Instant,
        "Maximum date to which the documents are selected"
        dateTo: Instant,
        "Page number"
        page: Int!,
        "Words and phrases to search in descriptions of the selected documents"
        search: String,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): [LeavingDocument!]! @deprecated(reason: "use allLeavingDocumentsPageable")
    "sort fields: [supplier, to, organization, docNumber, date, creationDate,status]"
    allLeavingDocumentsPageable(filter: DocumentFilterInput!, pageRequest: PageRequestInput!): LeavingDocumentPage!
    allLeavingDocumentsPageableV2(filter: InventoryDocumentFilterInputV2, pageRequest: PageRequestInput, sort: [AllLeavingDocumentsPageableV2Sort]): LeavingDocumentPage!
    "get all menu items for menu"
    allMenuItems(menuId: UUID): [MenuItem]
    "get all menu items by menu section id"
    allMenuItemsBySection(sectionId: UUID!): [MenuItem!]!
    "get all menu root sections by menu id"
    allMenuRootSections(menuId: UUID!): [MenuSection!]!
    "get all menu section colors"
    allMenuSectionColors: [MenuSectionColor!]!
    "get all menu sections by menu id"
    allMenuSections(menuId: UUID): [MenuSection!]!
    "get all menus by store id"
    allMenus(storeId: UUID!): [Menu]
    allMenusByStoreIds(storeIds: [UUID!]!): [Menu] @deprecated(reason: "use allMenusByStoreIdsPageable")
    allMenusByStoreIdsPageable(filter: MenuFilterInput, pageRequest: PageRequestInput, storeIds: [UUID!]!): MenuPage
    "Get all move documents for organization"
    allMoveDocuments(
        "Minimal date from which the documents are selected"
        dateFrom: Instant,
        "Maximum date to which the documents are selected"
        dateTo: Instant,
        "Page number"
        page: Int!,
        "Words and phrases to search in descriptions of the selected documents"
        search: String,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): [MoveDocument!]! @deprecated(reason: "use allMoveDocumentsPageable")
    "sort fields: [supplier, to, organization, docNumber, date, creationDate,status]"
    allMoveDocumentsPageable(filter: DocumentFilterInput!, pageRequest: PageRequestInput!, sort: [AllMoveDocumentsPageableSort!]): MoveDocumentPage!
    allMoveDocumentsPageableV2(filter: InventoryDocumentFilterInputV2, pageRequest: PageRequestInput!, sort: [AllMoveDocumentsPageableV2Sort!]): MoveDocumentPage!
    "Receive all payments for the order"
    allOrderPaymentsByOrderId(orderId: UUID!): [OrderPayment!]!
    "Get all organization invitations"
    allOrganizationInvitations: [OrganizationInvitation!]!
    "Get all organizations for currently logged account"
    allOrganizations: [Organization!]! @deprecated(reason: "Use allOrganizationsPageable")
    "Get all organizations for currently logged account"
    allOrganizationsPageable(filter: OrganizationFilterInput, pageRequestInput: PageRequestInput!): OrganizationPage!
    "Get all payment systems in the store"
    allPaySystemsByStoreId(storeId: UUID!): [PaySystem!]!
    "Get products from current organization (from all catalogs)"
    allProducts: [Product!]! @deprecated(reason: "use allCatalogProductsPageable")
    "Get products by catalog id if parent section id is null"
    allProductsByCatalogId(
        "Catalog ID"
        catalogId: UUID!
    ): [Product]! @deprecated(reason: "use allCatalogProductsPageable")
    allProductsByCatalogIdPageable(
        "Section id"
        catalogId: UUID,
        "which page to show, starts from 0"
        page: Int!,
        "how many items per page"
        size: Int!,
        "sort column"
        sortField: String,
        "sort order (e.g. asc, desc)"
        sortOrder: String
    ): [Product!]! @deprecated(reason: "use allCatalogProductsPageable")
    allProductsByCatalogIdRecursivePageable(
        "catalog id"
        catalogId: UUID,
        "which page to show, starts from 0"
        page: Int!,
        "how many items per page"
        size: Int!,
        "sort column"
        sortField: String,
        "sort order (e.g. asc, desc)"
        sortOrder: String
    ): [Product!]! @deprecated(reason: "use productsByCatalogIdRecursivePageable")
    "Get products by catalog id with subsections"
    allProductsByCatalogIdRecursively(
        "Catalog ID"
        catalogId: UUID!
    ): [Product]! @deprecated(reason: "use productsByCatalogIdRecursivePageable")
    "Get products by section id (one depth level)"
    allProductsBySectionId(
        "Section ID"
        sectionId: UUID!
    ): [Product]! @deprecated(reason: "use allCatalogProductsPageable")
    allProductsBySectionIdPageable(
        "which page to show, starts from 0"
        page: Int!,
        "Section id"
        sectionId: UUID,
        "how many items per page"
        size: Int!,
        "sort column"
        sortField: String,
        "sort order (e.g. asc, desc)"
        sortOrder: String
    ): [Product!]! @deprecated(reason: "use allCatalogProductsPageable")
    allProductsBySectionIdRecursivePageable(
        "which page to show, starts from 0"
        page: Int!,
        "Section id"
        sectionId: UUID,
        "how many items per page"
        size: Int!,
        "sort column"
        sortField: String,
        "sort order (e.g. asc, desc)"
        sortOrder: String
    ): [Product!]! @deprecated(reason: "use productsBySectionIdRecursivePageable")
    "Get products by section id with subsections"
    allProductsBySectionIdRecursively(
        "Section ID"
        sectionId: UUID!
    ): [Product]! @deprecated(reason: "use productsBySectionIdRecursivePageable")
    allProductsPageable(
        "which page to show, starts from 0"
        page: Int!,
        "how many items per page"
        size: Int!,
        "sort column"
        sortField: String,
        "sort order (e.g. asc, desc)"
        sortOrder: String
    ): [Product!]! @deprecated(reason: "use allCatalogProductsPageable")
    "Get all return documents for organization"
    allReturnDocuments(
        "Minimal date from which the documents are selected"
        dateFrom: Instant,
        "Maximum date to which the documents are selected"
        dateTo: Instant,
        "Page number"
        page: Int!,
        "Words and phrases to search in descriptions of the selected documents"
        search: String,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): [ReturnDocument!]! @deprecated(reason: "use allReturnDocumentsPageable")
    "sort fields: [supplier, to, organization, docNumber, date, creationDate,status]"
    allReturnDocumentsPageable(filter: DocumentFilterInput!, pageRequest: PageRequestInput!): ReturnDocumentPage!
    "Get all the stores for the organization. OrganizationId is taken from the header"
    allStores: [Store!]!
    "Get all the ghost sides"
    allStoresGhost: [StoreGhost!]!
    "Get all ghost sides by parent side"
    allStoresGhostByParentStore(parentStoreId: UUID!): [StoreGhost]!
    "Get all subscriptions for the store plan"
    allSubscriptions(storeId: UUID!): [_Subscription!]!
    "sort fields: [storeId, lifeTime, paymentDate, amount, status, paymentNumber, createdDate, lastModifiedDate]"
    allSubscriptionsPayments(filter: PaymoPaymentFilterInput!, pageRequest: PageRequestInput!): PaymoPaymentPage!
    "Get all payments for tariff subscriptions"
    allSubscritionsPayments(page: Int!, size: Int!, sortField: String, sortOrder: String, storeId: UUID!): [PaymoPayment!]! @deprecated(reason: "use allSubscriptionsPayments(filter: PaymoPaymentFilterInput!, pageRequest: PageRequestInput!)")
    "Get all suppliers for organization"
    allSuppliers(
        "Page number"
        page: Int!,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String
    ): [Supplier!]! @deprecated(reason: "use allSuppliersPageable")
    "sort fields: [type, contactPoint, companyName, email, address, organization, inn, kpp, phone, description, active, creationDate]"
    allSuppliersPageable(filter: SupplierFilterInput, pageRequest: PageRequestInput!, sort: [AllSuppliersPageableSort!]): SupplierPage!
    allTasks(kitchenWorkshopId: UUID!, page: Int!, size: Int!, sortField: String, sortOrder: String, statuses: [Status!], typeTasks: [TypeTask!]): [Task!]! @deprecated(reason: "Use allTasksByFilterPageable")
    "sort fields: [accountId organizationId kitchenWorkshopId inWarehouseId outWarehouseId storeId employeeId status typeTask createdAt inProgressedAt doneAt closedAt canceledAt taskNumber]"
    allTasksByFilterPageable(filter: AbstractTaskFilterInput!, pageRequest: PageRequestInput!): TaskPage!
    "Get all bank cards linked to the user's account"
    allUserPaymentCards: [UserPaymentCard!]!
    "Get all warehouse items for organization"
    allWarehouseItems(
        "Page number"
        page: Int!,
        "Words and phrases to search in name or quantity of the selected warehouse items"
        search: String,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String,
        "ID of warehouse items should belong to"
        warehouseId: UUID
    ): [WarehouseItem!]! @deprecated(reason: "use allWarehouseItemsPageable")
    "sort fields: [name,stockUnitId,warehouseId,quantity,creationDate,expense]"
    allWarehouseItemsPageable(filter: WarehouseItemFilterInput!, pageRequest: PageRequestInput!): WarehouseItemPage!
    "Get all warehouses for organization"
    allWarehouses(
        "Page number"
        page: Int!,
        "Page size"
        size: Int!,
        "Field to sort by"
        sortField: String,
        "Sorting order (asc/desc)"
        sortOrder: String
    ): [Warehouse!]! @deprecated(reason: "use allWarehousesPageable")
    "sort fields: [addressName, phone, email, symbolicCode, name, active, creationDate, lastModifiedDate]"
    allWarehousesPageable(filter: WarehouseFilterInput, pageRequest: PageRequestInput!, sort: [WarehousesPageableSort!]): WarehousePage!
    "Get arrival document by ID"
    arrivalDocument(
        "Arrival document ID"
        id: UUID!
    ): ArrivalDocument!
    availableLoyaltyPointsByOrder(order: UploadOrderInput): LoyaltyPoints @deprecated(reason: "use calculatePointsForOrder")
    availableStoresDebitLoyalty(currentDebitLoyaltyId: UUID): [Store!] @deprecated(reason: "no longer necessary")
    bankByBic(bic: String!): [BankSearchResponse]!
    bill(billId: UUID!): Bill!
    bills(pageRequest: PageRequestInput): BillPage!
    bonusProgram(id: UUID!): BonusProgram
    boundOverview(id: UUID!, type: Type!): BoundOverview!
    cachedCategories(orgId: UUID!): [CachedCategory!]
    cachedCategoriesWithProducts(orgId: UUID!): [CachedCategory!]
    calculatePointsForOrder(input: CalculatePointsInput!): PointsForOrder
    "Get catalog by id"
    catalog(
        "Catalog ID"
        id: UUID!
    ): Catalog!
    "Get organization catalog (organization id must be passed in headers)"
    catalogByOrganization: Catalog
    """

    Returns all catalog products and catalog sections without parent elements tree
    sort fields: [name]
    """
    catalogSearchPageable(
        "catalog id to search in"
        catalogId: UUID!,
        "Sku name or section name"
        name: String,
        "Page request"
        pageRequest: PageRequestInput
    ): InCatalogPage!
    "Get catalog section by id"
    catalogSection(
        "Section ID"
        id: UUID!
    ): CatalogSection!
    "Get section children"
    catalogSectionChildren(
        "Number of subsection levels"
        numberOfLevels: Int,
        "Section ID"
        sectionId: UUID!
    ): [CatalogSection]!
    "Get section parents"
    catalogSectionParents(
        "Section ID"
        sectionId: UUID!
    ): [CatalogSection]!
    catalogSectionParentsByStockUnit(
        "StockUnit ID"
        stockUnitId: UUID!
    ): [CatalogSection]!
    categoryReport(input: CategoryReportInput!): CategoryReportOutput!
    categoryReportTimeSeries(categoryReportInput: CategoryReportInput!, timeSeriesInput: TimeSeriesInput!): [CategoryReportTimeSeries!]!
    "Count whether chartReports exists for given list of stores"
    chartReportsExist(
        "IDs of stores to filter"
        storeIds: [UUID!]
    ): Boolean!
    "Check whether chartReports exists for given organizationId"
    chartReportsExistsForOrganization: Boolean!
    checkTrueApiCodes(codes: [String!]!, storeId: UUID!): TrueApiCodesResult
    consolidatedReport(input: ConsolidatedReportInput!): ConsolidatedReportOutput!
    consolidatedReportTimeSeries(input: ConsolidatedReportInput!, timeSeriesInput: TimeSeriesInput!): ConsolidatedTimeSeriesOutput!
    consolidatedReportXls(input: ConsolidatedReportInput!, sort: [ConsolidatedReportSort!]): ConsolidatedReportXlsOutput!
    "count all abc reports from selected period, stores and terminals"
    countAbcReports(
        "start of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): Long!
    "Get number of arrival documents for organization"
    countArrivalDocuments(
        "Minimal date from which the documents are counted"
        dateFrom: Instant,
        "Maximum date to which the documents are counted"
        dateTo: Instant,
        "Words and phrases to search in descriptions of the counted documents"
        search: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID!
    ): Long! @deprecated(reason: "use allArrivalDocumentsPageable")
    countDarkTasks(statuses: [Status!]): Long @deprecated(reason: "Use darkTasksByFilterPageable")
    "Get number of documents for organization"
    countDocuments(
        "Minimal date from which the documents are counted"
        dateFrom: Instant,
        "Maximum date to which the documents are counted"
        dateTo: Instant,
        "Statuses one of which counted documents should have"
        statuses: [StatusDocument!]
    ): Long! @deprecated(reason: "use allDocumentsPageable")
    "Get total employee count for current organization"
    countEmployees(activeFilter: Boolean, nameFilter: String): Long! @deprecated(reason: "use allEmployeesPageable")
    "Get number of inventory documents for organization"
    countInventoryDocuments(
        "Minimal date from which the documents are counted"
        dateFrom: Instant,
        "Maximum date to which the documents are counted"
        dateTo: Instant,
        "Words and phrases to search in descriptions of the counted documents"
        search: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): Long! @deprecated(reason: "use allInventoryDocumentsPageable")
    "Get number of kitchen workshops for organization"
    countKitchenWorkshops: Long @deprecated(reason: "use allKitchenWorkshopsPageable")
    "Get number of leaving documents for organization"
    countLeavingDocuments(
        "Minimal date from which the documents are counted"
        dateFrom: Instant,
        "Maximum date to which the documents are counted"
        dateTo: Instant,
        "Words and phrases to search in descriptions of the counted documents"
        search: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): Long @deprecated(reason: "use allLeavingDocumentsPageable")
    "Count menu elements"
    countMenuElements(filter: MenuElementFilterInput): Long!
    "Get number of move documents for organization"
    countMoveDocuments(
        "Minimal date from which the documents are counted"
        dateFrom: Instant,
        "Maximum date to which the documents are counted"
        dateTo: Instant,
        "Words and phrases to search in descriptions of the counted documents"
        search: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): Long! @deprecated(reason: "use allMoveDocumentsPageable")
    countOfOrders(filter: OrderFilterInput!): Long! @deprecated(reason: "Use ordersByFilterPageable")
    countOfSubscritionsPayments(storeId: UUID!): Long!
    countProducts: Long! @deprecated(reason: "use allCatalogProductsPageable")
    countProductsByCatalogId(
        "Catalog id"
        catalogId: UUID
    ): Long! @deprecated(reason: "use allCatalogProductsPageable")
    countProductsByCatalogIdRecursive(catalogId: UUID): Long! @deprecated(reason: "use productsByCatalogIdRecursivePageable")
    countProductsBySectionId(
        "Section id"
        sectionId: UUID
    ): Long! @deprecated(reason: "use allCatalogProductsPageable")
    "Get number of return documents for organization"
    countReturnDocuments(
        "Minimal date from which the documents are counted"
        dateFrom: Instant,
        "Maximum date to which the documents are counted"
        dateTo: Instant,
        "Words and phrases to search in descriptions of the counted documents"
        search: String,
        "ID of warehouse documents should belong to"
        warehouseId: UUID
    ): Long! @deprecated(reason: "use allReturnDocumentsPageable")
    "Get number of suppliers for organization"
    countSuppliers: Long! @deprecated(reason: "use allSuppliersPageable")
    countTasks(kitchenWorkshopId: UUID!, statuses: [Status!], typeTasks: [TypeTask!]): Long @deprecated(reason: "Use allTasksByFilterPageable")
    countWarehouseItemHistory(dateFrom: LocalDate!, dateTo: LocalDate!, search: String, warehouseId: UUID): Long
    "Get number of warehouse items for organization"
    countWarehouseItems(
        "Words and phrases to search in name or quantity of the counted warehouse items"
        search: String,
        "ID of warehouse items should belong to"
        warehouseId: UUID
    ): Long! @deprecated(reason: "use allWarehouseItemsPageable")
    countWarehouseItemsWrittenOff(dateFrom: LocalDate!, dateTo: LocalDate!, search: String, storeId: UUID!): Long
    countWarehouseItemsWrittenOffReportByWarehouse(dateFrom: LocalDate!, dateTo: LocalDate!, search: String, warehouseId: UUID!): Long
    "Get number of warehouses for organization"
    countWarehouses: Long! @deprecated(reason: "use allWarehousesPageable")
    countWrittenOffWarehouseItemsGroupedByWarehouse(dateFrom: LocalDate!, dateTo: LocalDate!, search: String): Long
    creditLoyalties(filter: CreditLoyaltyFilterInput, pageRequest: PageRequestInput): CreditLoyaltyPage @deprecated(reason: "use promotionPrograms")
    creditLoyalty(creditLoyaltyId: UUID!): CreditLoyalty @deprecated(reason: "use bonusProgram")
    customer(customerId: UUID!): Customer
    customerForCurrentDayWidget(widgetInput: CustomerForCurrentDayWidgetInput!): CustomerForCurrentDayWidgetOutput!
    customerGroup(customerGroupId: UUID!): CustomerGroup
    customerGroups(filter: CustomerGroupFilterInput, pageRequest: PageRequestInput, sort: [CustomerGroupsSort!]): CustomerGroupPage
    customerOrders(input: CustomerOrdersInput!, pageRequest: PageRequestInput): CustomerOrdersPage!
    customers(filter: CustomerFilterInput, pageRequest: PageRequestInput): CustomerPage
    dailyLoyaltyAnalytics(input: ChartInput!): [DailyLoyaltyAnalytics]
    darkTaskById(id: UUID!): DarkTask
    "sort fields: [accountId organizationId kitchenWorkshopId inWarehouseId outWarehouseId storeId employeeId status typeTask createdAt inProgressedAt doneAt closedAt canceledAt taskNumber]"
    darkTasksByFilterPageable(filter: DarkTaskFilterInput!, pageRequest: PageRequestInput!): DarkTaskPage!
    debitLoyalties(filter: DebitLoyaltyFilterInput, pageRequest: PageRequestInput): DebitLoyaltyPage @deprecated(reason: "use promotionPrograms")
    debitLoyalty(debitLoyaltyId: UUID!): DebitLoyalty @deprecated(reason: "use bonusProgram")
    devices(pageRequest: PageRequestInput): DevicePage!
    discountProgram(id: UUID!): DiscountProgram
    "Get employee by ID"
    employee(id: UUID!): Employee!
    "Get employee by account ID and organization ID"
    employeeByAccountIdAndOrganizationId(accountId: UUID!, organizationId: UUID!): Employee!
    "Get random available pin for employee"
    employeeGetAvailablePin: String! @deprecated(reason: "will be removed soon. use generateEmployeePinCode")
    "Check whether discount is bound to a specified catalog exists"
    existsDiscountByCatalogId(
        "ID of catalog for which the check is performed"
        catalogId: UUID!
    ): Boolean!
    "Check whether discount is bound to a specified product exists"
    existsDiscountByProductId(
        "ID of product for which the check is performed"
        productId: UUID!
    ): Boolean!
    "Check whether discount is bound to a specified section exists"
    existsDiscountBySectionId(
        "ID of section for which the check is performed"
        sectionId: UUID!
    ): Boolean!
    findByBarcode(barcode: String!): [StockUnit]!
    findKKTDocuments(filter: KKTDocumentFilterInput, pageRequest: PageRequestInput!): KKTDocumentUnionPage!
    "Menu elements"
    findMenuElements(filter: MenuElementFilterInput, pageable: PageRequestInput): MenuElementsPage!
    "Get terminal by fingerprint (hardware/software identifier"
    findTerminalByFingerprintAndStoreId(fingerprint: String!, storeId: UUID!): Terminal
    "Frequently bought together products. Based on given period, storeId and stockUnitId"
    frequentlyBoughtTogetherProducts(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "Comparable stockUnitId"
        stockUnitId: UUID!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [FrequentlyBoughtTogetherProducts]!
    generateUUID(count: Int!): [UUID!]!
    "Get popular products (which is also called `ABC report`) ordered by `revenue` descending for the selected period"
    getABCReportPageable(
        "start of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
        dateTo: LocalDate!,
        "which page to show, starts from 0"
        page: Int!,
        "how many items per page"
        size: Int!,
        "sort column"
        sortField: String,
        "sort order (e.g. asc, desc)"
        sortOrder: String,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [ABCReport!]! @deprecated(reason: "use abcReportPageable")
    getAnalyticsWarehouseItemMoveHistoriesDetails(filter: AnalyticsWarehouseItemMoveHistoriesDetailsFilterInput, pageRequest: PageRequestInput, sort: [GetAnalyticsWarehouseItemMoveHistoriesDetailsSort!]): AnalyticsWarehouseItemMoveHistoriesDetailsPage!
    getAnalyticsWarehouseItemMoveHistoryByStockUnit(filter: AnalyticsWarehouseItemMoveHistoryFilterInput!, pageRequest: PageRequestInput!): AnalyticsWarehouseItemMoveHistoryPage!
    getAnalyticsWarehouseItemMoveHistoryDetailsByStockUnit(filter: AnalyticsWarehouseItemMoveHistoryDetailsFilterInput!, pageRequest: PageRequestInput): AnalyticsWarehouseItemMoveHistoryDetailsPage!
    "Get data for main chart divided by days for the selected period"
    getChartReport(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [AnalyticsChartReport]!
    "Revenue, profit, bought quantity for a singleStockUnit."
    getChartReportForSingleStockUnit(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "Comparable stockUnitId"
        stockUnitId: UUID!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [AnalyticsChartReport]!
    "Revenue, profit, bought quantity for a singleStockUnit."
    getChartReportForSingleStockUnitHourly(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "Comparable stockUnitId"
        stockUnitId: UUID!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [AnalyticsChartReportHourly]!
    "Get data for main chart divided by months for the selected period and specific StockUnit"
    getChartReportForSingleStockUnitMonthly(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "Comparable stockUnitId"
        stockUnitId: UUID!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [AnalyticsChartReport]!
    "Revenue, profit, bought quantity for a singleStockUnit divided by Hour."
    getChartReportForSingleStockUnitSummary(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "Comparable stockUnitId"
        stockUnitId: UUID!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): AnalyticsChartReportSummary!
    "Get data for main chart divided by hours for the selected period"
    getChartReportHourly(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [AnalyticsChartReportHourly]!
    "Get data for main chart divided by months for the selected period"
    getChartReportMonthly(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [AnalyticsChartReport]!
    "Get summary data for given period"
    getChartReportSummary(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): AnalyticsChartReportSummary!
    "Get current employee. Returns employee, based on account id in authorization token and organization id passed in header"
    getCurrentEmployee: Employee!
    "Get discount by ID"
    getDiscount(
        "Discount ID"
        id: UUID!
    ): Discount!
    "Get data for discount chart divided by days for given period"
    getDiscountChartReport(
        "start date of a period"
        dateFrom: LocalDate!,
        "end date of a period"
        dateTo: LocalDate!,
        "IDs of discounts to filter"
        discountIds: [UUID!],
        "IDs of stores to filter"
        storeIds: [UUID!]
    ): [DiscountAnalyticsChartReport]!
    "Get data for discount chart divided by months for given period"
    getDiscountChartReportMonthly(
        "start date of a period"
        dateFrom: LocalDate!,
        "end date of a period"
        dateTo: LocalDate!,
        "IDs of discounts to filter"
        discountIds: [UUID!],
        "IDs of stores to filter"
        storeIds: [UUID!]
    ): [DiscountAnalyticsChartReport]!
    "Get date-time any discount in specified catalog got updated"
    getDiscountLastUpdated(
        "ID of catalog for which the check is performed"
        catalogId: UUID!
    ): Instant
    "Get data divided by hours for the selected period"
    getDiscountSalesByHour(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of discounts to filter"
        discountIds: [UUID!],
        "list of stores to filter"
        storeIds: [UUID!]
    ): [DiscountAnalyticsByHour]!
    "Get summary of data for given period"
    getDiscountSummary(
        "start date of a period"
        dateFrom: LocalDate!,
        "end date of a period"
        dateTo: LocalDate!,
        "IDs of discounts to filter"
        discountIds: [UUID!],
        "IDs of stores to filter"
        storeIds: [UUID!]
    ): DiscountAnalyticsSummary!
    "Get table view of discount applications"
    getDiscountTableView(
        "start date of a period"
        dateFrom: LocalDate!,
        "end date of a period"
        dateTo: LocalDate!,
        "ID of applied discount"
        discountId: UUID!,
        "IDs of products to filter"
        productIds: [UUID!],
        "IDs of stores to filter"
        storeIds: [UUID!]
    ): [DiscountTableViewRow]
    "Get discount by ID"
    getDiscountV2(
        "Discount ID"
        id: UUID!
    ): DiscountV2
    "Get all discounts for organization"
    getDiscounts(
        "Filter for discounts"
        filter: DiscountFilterInput
    ): [Discount!]! @deprecated(reason: "use getDiscountsV2")
    """

    Get date-time any discount in organization got updated.
    If no discounts were ever created for this organization, returns null.
    """
    getDiscountsLastUpdated: Instant
    "Get all discounts for organization"
    getDiscountsV2(filter: DiscountFilterInputV2, pageRequest: PageRequestInput): DiscountV2Page
    "Get employee invitation"
    getInvitation(inviteId: UUID!): Invitation!
    """

    "
    get unmapped menu from Yandex.Eats
    """
    getMenuFromYandexEats(yandexEatsUrl: String!): [YandexMenuCategory!]!
    "get menu last date updated. Menu updates when some of the child menu section or menu item updates"
    getMenuLastDateUpdated(menuId: UUID!): Instant!
    getOnlineMenuByShortId(onlineMenuShortId: String!): OnlineMenu!
    getOnlineMenuSectionByMenuSectionId(menuSectionId: UUID!): OnlineMenuSection!
    "Analytics for paysystems of payed orders"
    getPaySystemReport(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [PaySystemAnalytics]!
    "Get popular products ordered by `quantity` descending for the selected period"
    getPopularProducts(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [PopularProduct]! @deprecated(reason: "No longer supported")
    getPossibleDocumentCreationTypes(warehouseId: UUID!): [InventoryType!]!
    "Get data divided by hours for the selected period"
    getSalesByHour(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [AnalyticsByHour]! @deprecated(reason: "No longer supported")
    getSalesByWeekDay(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate!,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate!,
        "list of stores to filter"
        storeIds: [UUID!],
        "list of terminals to filter"
        terminalIds: [UUID!]
    ): [AnalyticsByDayOfWeek]! @deprecated(reason: "No longer supported")
    getTableBookings(filter: TableBookingFilterInput, pageable: PageableInput!, storeIds: [UUID!]!): TableBookingPage
    getUIState(key: String!): String
    "Warehouse item history from when it has been added to system"
    getWarehouseItemHistory(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate,
        "which page to show, starts from 0"
        page: Int!,
        "name of a warehouse item to search"
        search: String,
        "how many items per page"
        size: Int!,
        "sort field"
        sortField: String,
        "sort order (desc, asc)"
        sortOrder: String,
        "warehouse id"
        warehouseId: UUID
    ): [WarehouseItemHistory]! @deprecated(reason: "use getWarehouseItemHistoryPageable")
    "sort fields: [stockUnit, organization, warehouse, document, date, lastArrivalDate, name, quantity, initialQuantity, primePrice, event, reasonEvent, supplierId, storeId]"
    getWarehouseItemHistoryPageable(filter: WarehouseItemHistoryFilterInput!, pageRequest: PageRequestInput!): WarehouseItemHistoryPage!
    "All warehouse items history grouped by warehouse"
    getWarehouseItemsWrittenOffGroupWarehouseReport(
        "start of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
        dateFrom: LocalDate,
        "end of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
        dateTo: LocalDate,
        "which page to show, starts from 0"
        page: Int!,
        "name of a warehouse item to search"
        search: String,
        "how many items per page"
        size: Int!,
        "sort order (desc, asc)"
        sortOrder: String
    ): [WarehouseItemWrittenOffReport]!
    "Written off warehouse item's history"
    getWarehouseItemsWrittenOffReport(
        "start of a period (yyyy-MM-dd)"
        dateFrom: LocalDate,
        "end of a period (yyyy-MM-dd)"
        dateTo: LocalDate,
        "which page to show, starts from 0"
        page: Int!,
        "name of a warehouse item to search"
        search: String,
        "how many items per page"
        size: Int!,
        "sort order (desc, asc)"
        sortOrder: String,
        storeId: UUID!
    ): [WarehouseItemWrittenOffReport]!
    "Warehouse item history grouped by specific warehouse"
    getWarehouseItemsWrittenOffReportByWarehouse(
        "start of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
        dateFrom: LocalDate,
        "end of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
        dateTo: LocalDate,
        "which page to show, starts from 0"
        page: Int!,
        "name of a warehouse item to search"
        search: String,
        "how many items per page"
        size: Int!,
        "sort order (desc, asc)"
        sortOrder: String,
        "warehouse id"
        warehouseId: UUID!
    ): [WarehouseItemWrittenOffReport]!
    getWhereUsedPageable(pageRequest: PageRequestInput!, stockUnitId: UUID!): ProductPage!
    getYandexCategories: [String!]!
    getYandexMenu(storeId: UUID!): YandexMenu
    hourlyLoyaltyAnalytics(input: ChartInput!): [HourlyLoyaltyAnalytics]
    "get image with all available image sizes by id"
    imageById(id: UUID!): Image
    "get multiple images with all available image sizes"
    imagesByIds(id: [UUID!]!): [Image]!
    "get multiple images with urls to each size"
    imagesWithSize(images: [ImagesSizeInput!]!): AllImageWithSizes!
    "Get inventory document by ID"
    inventoryDocument(
        "Inventory document ID"
        id: UUID!
    ): InventoryDocument!
    "Check delivery avalability for location"
    isDeliveryAvailableInStore(latitude: Float!, longitude: Float!, storeId: UUID!): Boolean!
    "Get kitchen workshop by ID"
    kitchenWorkshop(
        "Kitchen workshop ID"
        id: UUID!
    ): KitchenWorkshop!
    "Get leaving by order document by ID"
    leavingByOrderDocument(
        "leaving by order document ID"
        id: UUID!
    ): LeavingByOrderDocument!
    "leaving by order documentId or/and orderId"
    leavingByOrderDocumentV2(filter: LeavingByOrderDocumentV2FilterInput!): LeavingByOrderDocument!
    "Get leaving document by ID"
    leavingDocument(
        "Leaving document ID"
        id: UUID!
    ): LeavingDocument!
    lightTasksByOrderId(orderId: UUID!): [LightTask!]!
    loyaltyAnalyticsSummary(input: ChartInput!): LoyaltyAnalyticsSummary
    loyaltyPointTransactions(orderId: UUID!, pageRequest: PageRequestInput): LoyaltyPointTransactionPage! @deprecated(reason: "use orderPointTransactions for correct logic of pointTransactionFact field")
    "get a menu by id"
    menu(id: UUID!): Menu!
    "get menu item by id"
    menuItem(id: UUID!): MenuItem!
    "get menu section by id"
    menuSection(id: UUID!): MenuSection!
    "get nested menu sections by parent menu section"
    menuSectionsBySection(sectionId: UUID!): [MenuSection!]!
    modifier(id: UUID!): Modifier! @deprecated(reason: "use modifierGroups")
    modifierGroup(id: UUID!): ModifierGroup! @deprecated(reason: "use modifierGroupById")
    modifierGroupById(id: UUID!): ModifierGroupOutput!
    modifierGroupWhereUsedAsModifier(pageRequest: PageRequestInput, stockUnitId: UUID!): ModifierGroupOutputPage!
    modifierGroups(filterInput: ModifierGroupFilterInput, pageRequest: PageRequestInput): ModifierGroupOutputPage!
    modifierGroupsByStore(pageRequest: PageRequestInput, storeId: UUID!): ModifierGroupPage! @deprecated(reason: "use modifierGroups")
    modifiersByIds(ids: [UUID!]!): [Modifier]! @deprecated(reason: "use modifierGroups")
    modifiersByModifierGroup(modifierGroupId: UUID!): [Modifier]! @deprecated(reason: "use modifierGroups")
    modifiersReport(input: ModifiersReportInput!): ModifiersReportOutput! @deprecated(reason: "use productsReportLinkedProducts")
    modifiersReportTimeSeries(input: ModifiersReportInput!, timeSeriesInput: TimeSeriesInput!): ModifiersReportTimeSeriesOutput! @deprecated(reason: "use productsReportProductModifiersTimeSeries")
    monthlyLoyaltyAnalytics(input: ChartInput!): [DailyLoyaltyAnalytics]
    mostPopularCategoriesWidget(input: MostPopularCategoriesWidgetInput!): MostPopularCategoriesWidgetOutput!
    mostPopularProductsWidget(input: MostPopularProductsWidgetInput!): MostPopularProductsWidgetOutput!
    "Get move document by ID"
    moveDocument(
        "Move document ID"
        id: UUID!
    ): MoveDocument
    orderById(orderId: UUID!): Order!
    "Receive payment for an order by its Id"
    orderPaymentById(paymentId: UUID!): OrderPayment!
    orderPointTransactions(orderId: UUID!, pageRequest: PageRequestInput): LoyaltyPointTransactionPage! @deprecated(reason: "use pointTransactions")
    orderTypeWidget(widgetInput: OrderTypeWidgetInput!): OrderTypeWidgetOutput!
    orderWidget(widgetInput: OrderWidgetInput!): OrderWidgetOutput!
    "Get all orders by filter"
    ordersByFilter(filter: OrderFilterInput!, page: Int!, size: Int!, sortField: String, sortOrder: String): [Order!]! @deprecated(reason: "Use ordersByFilterPageable")
    "sort fields: [totalAmount discountAmount dateLastPayedDate terminal status shiftId employeeId guestId store orderNumber payed canceled type createdDate lastModifiedDate]"
    ordersByFilterPageable(filter: OrderFilterInput!, pageRequest: PageRequestInput!): OrderPage!
    ordersReport(input: OrdersReportInput!): OrdersReportOutput!
    ordersReportTimeSeries(reportInput: OrdersReportInput!, timeSeriesInput: TimeSeriesInput!): OrdersReportTimeSeriesOutput!
    "Get organization by ID"
    organization(id: UUID!): Organization!
    "Get organization invitation by ID"
    organizationInvitation(organizationInvitationId: UUID!): OrganizationInvitation!
    organizationPaymentsExist: OrganizationPaymentsExistOutput!
    "Get popular products (which is also called `ABC report`) ordered by `revenue` descending for the selected period"
    overview: Overview!
    paySystemReportV2(input: PaySystemReportInput!): PaySystemReportOutput
    paymentReportTimeSeries(input: PaySystemReportInput!, timeSeriesInput: TimeSeriesInput!): PaySystemReportTimeSeriesOutput!
    paymentSystem(paymentSystemId: UUID!): PaymentSystem!
    paymentSystemWidget(widgetInput: PaymentSystemWidgetInput!): PaymentSystemWidgetOutput!
    "All payment systems available in organization"
    paymentSystems(filter: PaymentSystemsFilterInput, pageRequest: PageRequestInput!): PaymentSystemPage!
    pointTransactions(filter: PointTransactionFilterInput, pageRequest: PageRequestInput): PointTransactionPage!
    "Get cooking process by ID"
    process(
        "Process ID"
        id: UUID!
    ): Process!
    "Get product by id"
    product(
        "Product ID"
        id: UUID!
    ): Product!
    productArrivalsExist(id: UUID): Boolean
    products(filter: ProductsFilterInput, pageRequest: PageRequestInput): ProductPage!
    "sort fields: [name, active, catalog, section, createdDate]"
    productsByCatalogIdRecursivePageable(catalogId: UUID!, pageRequest: PageRequestInput): ProductPage!
    "sort fields: [name, active, catalog, section, createdDate]"
    productsBySectionIdRecursivePageable(pageRequest: PageRequestInput!, sectionId: UUID!): ProductPage!
    productsReport(input: ProductsReportInput!): ProductsReportOutput!
    productsReportLinkedProducts(input: ProductsReportLinkedProductsInput!): ProductsReportLinkedProductsOutput!
    productsReportLinkedProductsTimeSeries(input: ProductsReportLinkedProductsInput!, timeSeriesInput: TimeSeriesInput!): ProductsReportLinkedProductsTimeSeriesOutput!
    productsReportProductModifiers(input: ProductsReportProductModifiersInput!): ProductsReportProductModifiersOutput! @deprecated(reason: "use productsReportLinkedProducts")
    productsReportProductModifiersTimeSeries(input: ProductsReportProductModifiersInput!, timeSeriesInput: TimeSeriesInput!): ProductsReportProductModifiersTimeSeriesOutput! @deprecated(reason: "use productsReportLinkedProductsTimeSeries")
    productsReportTimeSeries(input: ProductsReportInput!, timeSeriesInput: TimeSeriesInput!): ProductsReportTimeSeriesOutput!
    productsWithIngredientsXls: ProductsWithIngredientsXlsOutput!
    productsWithoutIngredientsXls: ProductsWithoutIngredientsXlsOutput!
    promotionPrograms(filter: PromotionProgramFilterInput, pageRequest: PageRequestInput!, sort: [PromotionProgramSort!]): PromotionProgramPage
    "Get random color from colors directory"
    randomCatalogSectionColor: CatalogSectionColor!
    "get random color from existing colors in system"
    randomMenuSectionColor: MenuSectionColor!
    "Get return document by ID"
    returnDocument(
        "Return document ID"
        id: UUID!
    ): ReturnDocument!
    "Get data divided by hours for the selected period"
    salesByHourWidget(widgetInput: SalesByHourWidgetInput!): SalesByHourWidgetOutput!
    "Get sales by week day"
    salesByWeekDayWidget(widgetInput: SalesByWeekDayWidgetInput!): SalesByWeekDayWidgetOutput!
    salesTodayWidget(widgetInput: SalesTodayWidgetInput!): SalesTodayWidgetOutput!
    searchAddressByRequest(request: String!): AddressSearchResponse!
    searchBankByRequest(request: String!): [BankSearchResponse]!
    "Search counterparty by request (e.g. name, inn)"
    searchOrganizationByRequest(request: String!): OrganizationSearchResponse!
    sections(filter: SectionsFilterInput, pageRequest: PageRequestInput): CatalogSectionPage!
    sectionsByIds(pageRequest: PageRequestInput, sectionIds: [UUID!]!): CatalogSectionPage!
    servicePlanUsageSummary: ServicePlanUsageSummary!
    servicePlanV2(servicePlanId: UUID!): ServicePlanV2
    servicePlansV2(pageRequest: PageRequestInput): ServicePlanV2Page!
    shiftNumbers(pageRequest: PageRequestInput, storeIds: [UUID!]): ShiftNumberPage!
    stockUnitInventoryData(stockUnitIds: [UUID!]!, warehouseId: UUID!): [StockUnitInventoryData!]!
    stockUnits(filter: StockUnitFilterInput, pageRequest: PageRequestInput): StockUnitPage!
    "Get store by Id"
    store(storeId: UUID!): Store!
    "Get a ghost store"
    storeGhost(storeGhostId: UUID!): StoreGhost!
    storeReceiptSettings(storeId: UUID!): StoreReceiptSettings
    "All Stores pageable"
    stores(filter: StoreFilterInputV2, pageRequest: PageRequestInput!): StorePage!
    "Get stores by filter"
    storesByFilter(storeFilter: StoreFilterInput!): [Store!]!
    subscriber: Subscriber!
    "Get supplier by ID"
    supplier(
        "Supplier ID"
        id: UUID!
    ): Supplier!
    tableGroup(id: UUID!): TableGroup
    tableGroups(pageRequest: PageRequestInput!, storeId: UUID!): TableGroupPage
    tablesReport(input: TablesReportInput): TablesReportResponse!
    "Get tech card by ID"
    techCard(
        "Tech card ID"
        id: UUID!
    ): TechCard!
    "Get tech card by stock unit ID"
    techCardByStockUnit(
        "Stock unid ID"
        stockUnitId: UUID!
    ): TechCard!
    """

    allTechCards(first: Int, after: String, orgId: UUID!): TechCardConnection @connection(for: "TechCard")
    techCardsByTechCardItem(page: Int!, size: Int!, sortField: String, sortOrder: String, stockUnitId: UUID!): [TechCard]
    """
    techCardsByTechCardItemStockUnitIds(stockUnitIds: [UUID!]): [TechCard!]
    "Get available timezones"
    timezones: TimeZonesResponse!
    "Get an unpaid account for the store"
    unpaidPaymoPayment(storeId: UUID!): PaymoPayment
    userGroups: [UserGroup!]!
    "Get warehouse by ID"
    warehouse(
        "Warehouse ID"
        id: UUID!
    ): Warehouse!
    "Get warehouse item by ID"
    warehouseItem(
        "ID of warehouse item"
        id: UUID!
    ): WarehouseItem!
    warehouseItemLeftovers(filter: WarehouseItemLeftoverFilterInput, pageRequest: PageRequestInput!, sort: [WarehouseItemLeftoverSort!]): WarehouseItemLeftoverPage!
    warehouseItemsInfoByStockUnitIds(stockUnitIds: [UUID!]!, warehouseId: UUID!): [WarehouseItemInfo!]!
    warehouseItemsWrittenOffReportsExist: Boolean!
    warehouseStockUnitsIds(warehouseId: UUID!): [UUID!]!
    whereUsedAsModifier(pageRequest: PageRequestInput, stockUnitId: UUID!): ModifierGroupPage! @deprecated(reason: "use modifierGroupWhereUsedAsModifier")
}

type ReRegistrationDocument implements KKTDocument {
    agentSigns: [AgentSign]
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int
    documentType: DocumentType
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String
    fnsUrl: String
    kktRegistrationNumber: String
    machineSerial: String
    modeSigns: [RegistrationModeSign]
    ofd: Ofd
    ofdTicket: OfdTicket
    operator: Operator
    organizationEmail: String
    organizationName: String
    organizationVatin: String
    reason: [ReRegistrationReason]
    registrationNumber: String
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
    taxSystems: [TaxSystem]
}

type ReceiptItemWrapper {
    barcode: ItemBarcode
    position: Position
    text: ItemText
}

type ReceiptWish {
    text: String!
}

type RegistrationDocument implements KKTDocument {
    agentSigns: [AgentSign]
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int
    documentType: DocumentType
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String
    fnsUrl: String
    kktRegistrationNumber: String
    machineSerial: String
    modeSigns: [RegistrationModeSign]
    ofd: Ofd
    ofdTicket: OfdTicket
    operator: Operator
    organizationEmail: String
    organizationName: String
    organizationVatin: String
    registrationNumber: String
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
    taxSystems: [TaxSystem]
}

type RequestLimitInfo {
    retriesRemaining: Int!
    timeToNextRequestMillis: Int!
}

"Rest password response"
type ResetPasswordResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type ResultLeavingItem {
    coreItem: Boolean!
    currency: String
    id: UUID!
    name: String!
    parentStockUnitId: UUID
    primePrice: BigDecimal!
    quantity: BigDecimal!
    stockUnitId: UUID!
    unit: UnitType!
}

"Return document data"
type ReturnDocument {
    "Creation date"
    creationDate: Instant
    "Execution date"
    date: Instant
    "Description"
    description: String
    "Number"
    docNumber: Long
    "Returned items"
    documentItems: [DocumentItem!]
    "Warehouse that items got returned from"
    from: Warehouse
    "Return document ID"
    id: UUID
    "Organization that created the document"
    organization: Organization
    "Status"
    status: StatusDocument
    "Supplier that items get returned to"
    supplier: Supplier
    "Type"
    typeDocument: TypeDocument
}

type ReturnDocumentPage implements Page {
    content: [ReturnDocument!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Revoke employee invitation response"
type RevokeEmployeeInviteResponse {
    employeeId: UUID!
}

type RevokeSupportControlClaimResult {
    id: UUID!
}

type SalesByHour {
    "average hourly check"
    averageHourlyCheck: BigDecimal!
    "average hourly profit"
    averageHourlyProfit: BigDecimal!
    "average hourly revenue"
    averageHourlyRevenue: BigDecimal!
    "hour"
    hour: Int!
    "total hourly checks count"
    totalHourlyChecksCount: Int!
    "total hourly guests count"
    totalHourlyGuestsCount: Int!
}

type SalesByHourWidgetOutput {
    "elements sales by hour"
    elements: [SalesByHour!]!
}

type SalesByWeekDay {
    averageWeeklyCheck: BigDecimal!
    averageWeeklyProfit: BigDecimal!
    averageWeeklyRevenue: BigDecimal!
    dayOfWeek: Int!
    totalWeeklyChecksCount: Int!
    totalWeeklyGuestsCount: Int!
}

type SalesByWeekDayWidgetOutput {
    elements: [SalesByWeekDay!]!
}

type SalesToday {
    averageCheck: BigDecimal!
    checksCount: Int!
    guestsCount: Int!
    profit: BigDecimal!
    revenue: BigDecimal!
}

type SalesTodayWidgetOutput {
    salesToday: SalesToday!
}

type SaveKKTDocumentsPayload {
    success: Boolean!
}

type SaveStoreReceiptSettingsResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: StoreReceiptSettings
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type SaveStoreTableGroupsResult implements RequestResult {
    errorMessage: String
    output: TableGroupsOutput
    result: TransactionResult!
    transactionId: UUID
}

"Schedule"
type Schedule {
    "Days of the week"
    daysOfWeek: [DayOfWeek!]
    "Start time 'HH: mm'"
    fromTime: String
    "Schedule type"
    scheduleType: ScheduleType
    "End time 'HH: mm'"
    toTime: String
}

type Selection {
    all: Boolean!
    excluded: [UUID!]
    selected: [UUID!]
}

"Employee invitation response"
type SendEmployeeInviteResponse {
    employeeId: UUID!
    token: String!
}

"Rate"
type ServicePlan {
    "Tariff code"
    code: String!
    "Tariff Description"
    description: String
    haveTrial: Boolean!
    "Tariff Id"
    id: UUID!
    "Tariff name"
    name: String!
    "Tariff options"
    options: [ServicePlanOption!]!
    "Sequential number of the tariff in the list of tariffs"
    position: Int
    "Trial period. ISO 8601 format: P (n) Y (n) M (n) DT (n) H (n) M (n) S"
    trialPeriodDuration: String
}

"Tariff Option"
type ServicePlanOption {
    "Tariff Option Cost"
    amount: AmountData!
    "Description of the tariff option"
    description: String
    "Duration of tariff option. ISO 8601 format: P (n) Y (n) M (n) DT (n) H (n) M (n) S"
    duration: String!
    "Tariff option id"
    id: UUID!
    "Serial number of the tariff option"
    position: Int
}

type ServicePlanUsageSummary {
    isFreeAccount: Boolean!
    isInDebt: Boolean!
    organizationId: UUID!
    remainingDays: Int
    servicePlan: ServicePlanV2!
}

type ServicePlanV2 {
    description: String
    id: UUID!
    isPersonal: Boolean
    name: String!
    price: AmountData
    servicesDescription: String
    terms: [ServicePlanV2Terms!]!
    trialPeriod: Int
}

type ServicePlanV2Page implements Page {
    content: [ServicePlanV2!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ServicePlanV2Terms {
    deviceType: TermsDeviceType!
    limit: Int!
}

type ShiftClosingDocument implements KKTDocument {
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int
    documentType: DocumentType
    documentsCount: Int
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String
    ofd: Ofd
    ofdTicket: OfdTicket
    operator: Operator
    organizationName: String
    organizationVatin: String
    registrationNumber: String
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
}

type ShiftNumberPage implements Page {
    content: [Int!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type ShiftOpeningDocument implements KKTDocument {
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int
    documentType: DocumentType
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String
    ofd: Ofd
    ofdTicket: OfdTicket
    operator: Operator
    organizationName: String
    organizationVatin: String
    registrationNumber: String
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
}

type SignInRequestRateLimitError implements ApiException {
    message: String
}

"First-phase auth response, describes identity type (email, phone, etc.) and password-based authorization availability for current request"
type SignInResponse {
    "Identity type, such as email or phone"
    authType: IdentityType!
    "Password-based auth availability. Actually show that account has password set"
    hasPassword: Boolean!
    requestId: UUID!
}

type SignInResponseData {
    authInfo: SignInResponse
    exceptions: [SignInRequestError!]
    requestLimitInfo: RequestLimitInfo
}

type SnapshotOrderEmployee {
    firstName: String
    id: UUID
    lastName: String
}

"SNO (taxation system) with source location"
type SnoValue {
    "Source ID"
    entityId: UUID
    "Source where SNO has been got"
    entityType: CatalogEntityType
    "SNO value"
    sno: Sno
}

"StockUnit output data"
type StockUnit {
    barcodes: [Barcode!]
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    "StochUnit ID"
    id: UUID!
    "StochUnit list of images"
    images: [Image!]!
    "StochUnit name"
    name: String!
    "Position type of nearest parent catalog element, if available"
    parentPositionType: PositionType
    "SNO (taxation system) of nearest parent catalog element, if available"
    parentSnoValue: SnoValue
    "VAT (tax rate) of nearest parent catalog element, if available"
    parentVatValue: VatValue
    "Stock unit position type with source info"
    positionType: PositionType
    "StochUnit prime price"
    primePrice: AmountData
    "quantity by subUnit"
    quantity: BigDecimal!
    "StochUnit sale price"
    salePrice: AmountData!
    "Stock unit SNO (taxation system) with source info"
    snoValue: SnoValue
    "unit type kg, g, l,ml"
    subUnit: UnitType
    "StockUnit TaxProfile"
    taxProfile: TaxProfile @deprecated(reason: "use snoValue & taxValue")
    "StochUnit techCard"
    techCard: TechCard
    "StochUnit unit type"
    unit: UnitType!
    unitTypesMatchList: [UnitType!]!
    "Stock unit VAT (tax rate) with source info"
    vatValue: VatValue
    "weighable"
    weighable: Boolean!
}

type StockUnitAppliedModifier {
    amount: AmountData!
    id: UUID!
    modifierGroup: AppliedModifierGroup!
    modifierId: UUID!
    name: String!
    positionTypeCode: PositionTypeCode!
    primePrice: AmountData!
    quantity: MeasureData!
    resultAmount: AmountData
    salePrice: AmountData!
    stockUnitId: UUID!
    vatType: VatType!
}

"Stock unit created event"
type StockUnitCreatedDto {
    "Created stock unit"
    stockUnit: StockUnit!
}

"Stock unit deleted event"
type StockUnitDeletedDto {
    "Deleted stock unit ID"
    stockUnitId: UUID!
}

type StockUnitInventoryData {
    arrivalFromLastInventory: BigDecimal
    lastInventoryDate: Instant
    lastInventoryDocumentId: UUID
    leftoverOnLastInventory: BigDecimal
    planQuantity: BigDecimal
    soldFromLastInventory: BigDecimal
    stockUnitId: UUID!
    writtenOffFromLastInventory: BigDecimal
}

type StockUnitModifier {
    id: UUID!
    name: String!
    pinned: Boolean!
    sort: Int!
    stockUnit: StockUnit!
}

"Page of catalog sections"
type StockUnitPage implements Page {
    content: [StockUnit!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"Stock unit updated event"
type StockUnitUpdatedDto {
    "Updated stock unit"
    stockUnit: StockUnit!
}

"Store"
type Store {
    "Sign of disconnection of the store"
    active: Boolean!
    "Store actual address"
    actualAddress: String
    "Store address"
    address: String @deprecated(reason: "use actualAddress")
    "Checking account"
    bankAccount: String
    bankName: String
    bic: String
    "Store directory id"
    catalogId: UUID!
    ceo: String
    correspondentAccount: String
    countOfMenu: Long!
    countOfTerminals: Long!
    "Currency in which settlements are made in the store"
    currency: String!
    "Cost of delivery"
    deliveryAmount: AmountData
    "Array of coordinates with latitude and longitude for delivery area"
    deliveryArea: [Coordinates!]
    "Maximum delivery time 'HH: mm'"
    deliveryTimeMax: String
    "Minimum delivery time 'HH: mm'"
    deliveryTimeMin: String
    "List of Id device store servers"
    deviceServerIdList: [UUID!] @deprecated(reason: "unused")
    "Coordinates where store is located"
    geoLocation: Coordinates
    "Id store"
    id: UUID!
    "Checkpoint"
    kpp: String
    "Time of the last check modification yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    lastReceiptModifiedDate: Instant @deprecated(reason: "No longer supported")
    "Legal address"
    legalAddress: String
    "Store URL prefix"
    linkPrefix: String @deprecated(reason: "unused")
    "Name of shop"
    name: String!
    "OGRN"
    ogrn: String
    okpo: String
    "Store organization"
    organization: Organization!
    "Organization ID"
    organizationId: UUID!
    "Name of the organization"
    organizationName: String
    "List of payment systems"
    paySystems: [PaySystem!]
    phone: String
    "Sequential number in the list of stores of the organization"
    position: Int
    "Position type"
    positionTypeCode: PositionTypeCode!
    "Post address"
    postAddress: String
    "The postal address corresponds to the legal"
    postAddressCoincidence: Boolean
    "Index"
    postalCode: String
    registrationDate: Instant
    "Respect store working schedule during table booking"
    respectWorkingHoursForBooking: Boolean
    "List of store schedules"
    schedules: [Schedule!]
    "Store number"
    serialNumber: Long
    shippingWarehouse: Warehouse
    "Id store delivery warehouse"
    shippingWarehouseId: UUID
    signer: String
    signerBase: SignerBase
    "Is table booking feature active for this store"
    tablesBookingFeatureEnabled: Boolean
    "Is tables feature enabled in this store"
    tablesFeatureEnabled: Boolean!
    "Tax profile"
    taxProfile: TaxProfile @deprecated(reason: "No longer supported")
    "Terminal List"
    terminals: [Terminal!]
    "Store type"
    type: StoreType!
    "INN"
    vatin: String
    "Is working schedule enabled"
    workingScheduleEnabled: Boolean
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String!
}

type StoreDeletedDto {
    "Created store"
    storeId: UUID!
}

type StoreGhost {
    "Sign of disconnection of the ghost store"
    active: Boolean!
    "Ghost store actual address"
    actualAddress: String
    "Ghost store address"
    address: String @deprecated(reason: "use actualAddress")
    "Id of the ghost store directory"
    catalogId: UUID!
    "Cost of delivery"
    deliveryAmount: AmountData
    "Array of coordinates with latitude and longitude for deliveryArea"
    deliveryArea: [Coordinates!]
    "Maximum delivery time 'HH: mm'"
    deliveryTimeMax: String
    "Minimum delivery time 'HH: mm'"
    deliveryTimeMin: String
    "Coordinates where storeGhost is located"
    geoLocation: Coordinates
    "Id store-ghost"
    id: UUID!
    "Name of the ghost store"
    name: String!
    "Id of the organization of the store-ghost"
    organizationId: UUID!
    "Id of the parent store"
    parentStoreId: UUID!
    "Sequential number in the list of the parent store"
    position: Int
    "List of ghost store schedules"
    schedules: [Schedule!]
    "Id store supply store ghost"
    shippingWarehouseId: UUID
    "The name of the Time Zone in which the ghost store operates (IANA Time Zone Database)"
    zoneId: String!
}

"MenuId corresponds to storeId where menu has been created"
type StoreMenu {
    menuId: UUID!
    storeId: UUID!
}

type StorePage implements Page {
    content: [Store!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type StoreReceiptSettings {
    "Free comment to be printed"
    freeComment: String
    "Flag to enable printing of a custom comment on the receipt"
    printFreeComment: Boolean!
    "Flag to enable printing of an order comment on the receipt"
    printOrderComment: Boolean!
    "Flag to enable printing of a store logo on the receipt"
    printStoreLogo: Boolean!
    "Flag to enable printing of a store name on the receipt"
    printStoreName: Boolean!
    "Flag to enable printing of a wishes on the receipt"
    printWishes: Boolean!
    "Store logo image id"
    storeLogoImageId: UUID
    "Store name to be printed"
    storeName: String
    "Wishes"
    wishes: [ReceiptWish!]
}

type StoreResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Store
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type StoreUpdatedDto {
    "Created store"
    store: Store!
}

type Subscriber {
    addonsSubscriptions: [AddonSubscription]!
    deviceRestrictions: [DeviceRestriction!]!
    deviceUsages: [DeviceUsage]!
    organizationId: UUID!
    servicePlan: ServicePlanV2!
    validUntil: Instant
}

type SubscriberResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Subscriber
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type Subscription {
    "Employee subscription"
    employeeChanges: EmployeeChange!
    "Subscribes to updates on goal completion statuses. Receives GoalItem every time the corresponding goal gets completed."
    goalUpdates: GoalItem
    "Menu item changes by menu ID"
    menuItemChanges(menuId: UUID!): MenuItemSubscriptionDto!
    "Menu section changes by menu ID"
    menuSectionChanges(menuId: UUID!): MenuSectionSubscriptionDto!
    "Subscribe organization changes"
    organizationChanges: Organization
    "Stock unit changes by menu ID"
    stockUnitPosChanges(menuId: UUID!): StockUnitSubscriptionDto!
    storeChanges(storeId: UUID!): StoreSubscriptionDto!
    "Subscribe employee changes"
    subscribeEmployeeChanges: EmployeeSubscription @deprecated(reason: "use employeeChanges")
    "Subscribe on all notifications"
    subscribeOnNotifications: AccountNotification!
    subscribeOrderChanges(storeId: UUID!): OrderEvent
    subscribePaySystemChanges(storeId: UUID!): PaySystemEvent @deprecated(reason: "pay systems are changed with store updates, subscribe to storeChanges")
    "Table booking changes subscription"
    subscribeTableBookings(storeId: UUID!): TableBookingSubscriptionResult
    "Subscribe tech support claim issuing for current organization"
    subscribeTechSupportClaims: TechSupportClaim @deprecated(reason: "use supportControlClaimChanges")
    "Support control claims subscription. Catches any claim update (issued/confirmed/extended/revoked/declined)"
    supportControlClaimChanges: SupportControlClaim! @deprecated(reason: "use supportControlClaimChangesList")
    "Support control claims subscriptions list. Catches any claim update (issued/confirmed/extended/revoked/declined)"
    supportControlClaimChangesList: [SupportControlClaim!]
}

type SubscriptionsCancellationNotification {
    createdDate: Instant
    id: UUID
    message: String
    type: NotificationType
}

type SubscriptionsDueToExpireNotification {
    createdDate: Instant
    id: UUID
    message: String
    type: NotificationType
}

type SuccessfulPaymentNotification {
    createdDate: Instant
    id: UUID
    message: String
    type: NotificationType
}

"Supplier data"
type Supplier {
    "Is supplier active"
    active: Boolean!
    "Address"
    address: String
    "Company name"
    companyName: String
    "Name of contact in supplier"
    contactPoint: String
    "Creation date-time in system"
    creationDate: Instant
    "Short description"
    description: String
    "E-mail"
    email: String
    "Supplier ID"
    id: UUID
    "INN"
    inn: String
    "KPP"
    kpp: String
    "Phone"
    phone: String
    "total costs by supplier"
    totalCosts: BigDecimal
    "Legal type of supplier"
    type: TypeSupplier
}

type SupplierPage implements Page {
    content: [Supplier!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type SupplierResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Supplier
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type Supply {
    arrivalDate: Instant
    docNumber: Long
    documentId: UUID
    primePrice: AmountData
    quantity: BigDecimal
    startUsingDate: Instant
    supplierId: UUID
    supplierName: String
}

type SupportControlClaim {
    accessCode: String
    clientAccountId: UUID
    confirmationCount: Int!
    confirmed: Boolean!
    declined: Boolean!
    expiresAt: Instant!
    id: UUID!
    organizationId: UUID!
    revoked: Boolean!
    serverTime: Instant!
    supportAccountId: UUID!
}

type Table {
    id: UUID!
    name: String!
    position: Int!
    seatsCount: Int!
}

type TableBooking {
    clientId: UUID
    clientName: String
    comment: String
    dateEnd: LocalDate!
    "Local date string , with no associated timezone, such as YYYY-MM-DD"
    dateStart: LocalDate!
    dateTimeEnd: DateTime!
    "A date-time at UTC. Useful for comparing, overlaps search"
    dateTimeStart: DateTime!
    "Duration in seconds"
    duration: Int!
    guestCount: Int!
    id: UUID!
    status: TableBookingStatus!
    tableGroupId: UUID!
    tableGroupName: String
    tableId: UUID!
    tableName: String
    timeEnd: LocalTime!
    "Time in the ISO-8601 calendar system, such as 10:15:30"
    timeStart: LocalTime!
}

type TableBookingCreated {
    tableBooking: TableBooking!
}

type TableBookingPage implements Page {
    content: [TableBooking!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type TableBookingUpdated {
    tableBooking: TableBooking!
}

type TableGroup {
    archived: Boolean!
    id: UUID!
    name: String!
    storeId: UUID!
    tables: [Table!]
}

type TableGroupPage implements Page {
    content: [TableGroup!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type TableGroupRow {
    id: UUID
    name: String
    rowData: TablesReportRowData!
    storeName: String!
    tableRows: [TableRow!]
}

type TableGroupsOutput {
    tableGroups: [TableGroup!]
}

type TableRow {
    id: UUID!
    name: String!
    rowData: TablesReportRowData!
}

type TablesReportResponse {
    tableGroupRows: [TableGroupRow!]
    total: TablesReportRowData!
}

type TablesReportRowData {
    averageCheck: BigDecimal!
    guestCount: Int!
    orderCount: Int!
    profit: BigDecimal!
    revenue: BigDecimal!
}

type Task {
    accountId: UUID
    canceledAt: Instant
    closedAt: Instant
    createdAt: Instant
    doneAt: Instant
    employeeId: UUID
    id: UUID!
    inProgressedAt: Instant
    inWarehouseId: UUID
    kitchenWorkshopId: UUID
    originalTaskId: UUID!
    outWarehouseId: UUID
    status: Status
    store: Store!
    taskNumber: Long
    typeTask: TypeTask
}

"Task item data"
type TaskItem {
    "Ingredient"
    ingredients: [Ingredient]
    "Quantity in specified units"
    quantity: BigDecimal!
    "Tech card ID"
    techCard: TechCard!
    "Measurement unit type"
    unitType: UnitType!
}

type TaskPage implements Page {
    content: [Task!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

"""

Tax profile
!!! @deprecated Use SnoValue & VatValue instead
"""
type TaxProfile {
    "TaxProfileSource id"
    entityId: UUID
    "Source, where TaxProfile has been got"
    entityType: CatalogEntityType
    "Taxation system"
    sno: Sno!
    "VAT type"
    vat: VatType!
}

"Tech card data"
type TechCard {
    "Tech card ID"
    id: UUID!
    "Organization tech card belongs to"
    organization: Organization!
    "Available cooking processes"
    processItems: [ProcessItem!]!
    "Description of tech card and cooking process"
    processOfCooking: String
    "Stock unit"
    stockUnit: StockUnit
    "Items of tech card"
    techCardItems: [TechCardItem!]!
}

"Tech card item data"
type TechCardItem {
    "Brutto quantity of item in specified units"
    brutto: Float
    "Measurement unit type"
    bruttoUnitType: UnitType
    id: UUID
    "Netto quantity of item in specified units"
    netto: Float
    "Cooking processes required for this item"
    processItems: [ProcessItem!]!
    "Stock unit"
    stockUnit: StockUnit
}

type TechSupportClaim {
    accessCode: String!
    "Client account id"
    clientAccountId: UUID!
    confirmationCount: Int!
    confirmed: Boolean!
    expired: Boolean!
    expiresAt: Instant!
    "Tech support claim id"
    id: UUID!
    "Organization tech support claim issued for"
    organizationId: UUID!
    "Tech support assistant account"
    requestedByAccountId: UUID!
    "Claim revoked by"
    revokedByAccountId: UUID
    "Support account id"
    supportAccountId: UUID!
}

"Terminal store"
type Terminal {
    "Terminal disconnection sign"
    active: Boolean!
    "Terminal id"
    id: UUID!
    "Terminal menu"
    menu: Menu
    "Terminal menu id"
    menuId: UUID
    "Terminal name"
    name: String!
    "Last order sequence number"
    orderSequence: Long
    "Sequential number of the terminal in the list of terminals"
    position: Int
    "Terminal number"
    serialNumber: Long
    "Terminal store"
    store: Store
    "Terminal store id"
    storeId: UUID
}

type TerminalAcquiringInfo {
    "Message in case an error is risen when acquiring terminal"
    errorMessage: String
    "Terminal fingerprint"
    fingerprint: String!
    "Terminal ID"
    id: UUID!
    "Flag whether terminal acquistion was successful"
    isSuccessful: Boolean!
    "Terminal menu ID"
    menuId: UUID
    "Terminal name"
    name: String
    "Terminal store ID"
    storeId: UUID
}

type TerminalSaveOrderSequenceResult {
    id: UUID!
}

type TerminalSaveResult {
    id: UUID!
}

type TextAppliedModifier {
    id: UUID!
    modifierGroup: AppliedModifierGroup!
    modifierId: UUID!
    name: String!
}

type TextModifier {
    id: UUID!
    name: String!
    pinned: Boolean!
    sort: Int!
}

type TimeZone {
    zoneId: String!
}

type TimeZonesResponse {
    timeZones: [TimeZone!]!
}

type TrueApiCodeFailedCheck {
    codeType: TrueApiCodeFailedCheckCodeType!
    message: String
}

type TrueApiCodeInfo {
    checked: Boolean!
    code: String!
    failedChecks: [TrueApiCodeFailedCheck!]
}

type TrueApiCodesResult {
    requestId: UUID!
    result: [TrueApiCodeInfo!]!
}

type URL {
    "image height"
    height: Int!
    "size type (e.g. `original`, `large` or 'medium`)"
    sizeType: String!
    "image url"
    url: String!
    "image width"
    width: Int!
}

"Action on notification that opens an URL"
type URLNotificationAction {
    "URL to call for this action"
    url: String!
}

type UiStateResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Boolean
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type UnsuccessfulPaymentNotification {
    createdDate: Instant
    id: UUID
    message: String
    type: NotificationType
}

"Employee pin update response."
type UpdateEmployeePinCodeResponse {
    pin: String!
}

type UpdateTableBookingResult implements RequestResult {
    errorMessage: String
    output: TableBooking
    result: TransactionResult!
    transactionId: UUID
}

type UploadImageResponse {
    mutationResultList: [MutationResult!]!
}

"User group"
type UserGroup {
    "Unique group code"
    code: RoleCode!
    "User group ID"
    id: UUID!
    "User group name"
    name: String
}

"User bank card"
type UserPaymentCard {
    "Default card attribute"
    defaultCard: Boolean!
    "Card id"
    id: UUID!
    "Payment card number with mask"
    pan: String!
    "Payment system"
    type: String
}

"VAT (tax rate) with source location"
type VatValue {
    "Source ID"
    entityId: UUID
    "Source where VAT has been got"
    entityType: CatalogEntityType
    "VAT value"
    vat: VatType
}

"Warehouse data"
type Warehouse {
    "Is warehouse active"
    active: Boolean!
    "Address"
    addressName: String
    "Whether warehouse archived or not"
    archived: Boolean
    "Date when warehouse has been archived"
    archivedDate: Instant
    "Hours of business in arbitrary format"
    businessHours: String
    "Creation date-time in system"
    creationDate: Instant
    "Short description"
    description: String
    "E-mail"
    email: String
    "GPS latitude"
    gpsLatitude: String
    "GPS longitude"
    gpsLongitude: String
    "Warehouse ID"
    id: UUID
    "Name"
    name: String
    "Organization owning the warehouse"
    organization: Organization
    "Phone"
    phone: String
    "Is warehouse a location for picking up"
    pickupLocation: Boolean!
    "Is warehouse a shipping center"
    shippingCenter: Boolean!
    "Website"
    site: String
    "Corresponding store ids to whom particular warehouse belongs to"
    stores(pageRequest: PageRequestInput): StorePage
    "Number of served stores"
    storesCount: Long
    "Arbitrary symbolic code"
    symbolicCode: String
    "By default warehouse timezone sets on an address base or Moscow timezone, user should verify whether timezone has been set correctly"
    timezoneVerified: Boolean
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String
}

"Warehouse item data"
type WarehouseItem {
    "Warehouse item ID"
    id: UUID
    lastArrivalQuantity: BigDecimal
    "Name"
    name: String
    "ID of owning organization"
    organizationId: UUID
    "Quantity of items"
    quantity: Float
    "Stock unit"
    stockUnit: StockUnit
    supplies: [Supply!]
    "ID of owning warehouse"
    warehouseId: UUID
}

"Warehouse item"
type WarehouseItemHistory {
    "date of an history case"
    date: LocalDate!
    "document id of a warehouse item"
    documentId: UUID
    "document number of a warehouse item"
    documentNumber: Long
    "inocation event for getting history (arrival, write off, recalculation"
    event: WarehouseItemEvent
    "last arrived date"
    lastArrivalDate: LocalDate
    "organization name of a warehouse item"
    organizationName: String
    "prime price of a warehouse item"
    primePrice: AmountData
    "quantity of a warehouse item"
    quantity: BigDecimal
    "reason for warehouse item movement"
    reasonEvent: WarehouseItemReasonEvent
    "stock unit of a warehouse item"
    stockUnitName: String
    "warehouse name of a warehouse item"
    warehouseName: String
}

type WarehouseItemHistoryPage implements Page {
    content: [WarehouseItemHistory!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type WarehouseItemInfo {
    exists: Boolean!
    quantity: Float!
    stockUnitId: UUID!
}

type WarehouseItemLeftover {
    lastArrivalDate: Instant
    lastArrivalDocument: ArrivalDocument
    name: String
    primePrice: AmountData!
    product: Product!
    productId: UUID!
    quantity: BigDecimal!
    sectionName: String
    stores: [Store!]
    totalAmount: BigDecimal!
    type: ProductType
    unitType: UnitType!
    warehouseName: String!
}

type WarehouseItemLeftoverPage implements Page {
    content: [WarehouseItemLeftover!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type WarehouseItemPage implements Page {
    content: [WarehouseItem!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type WarehouseItemWrittenOffReport {
    "average prime price"
    averagePrice: BigDecimal
    "currency unit of a warehouse item"
    currencyUnit: String
    "last arrival quantity"
    lastArrivalQuantity: BigDecimal
    "stock unit of a warehouse item"
    stockUnitId: UUID
    "stock unit of a warehouse item"
    stockUnitName: String
    "total quantity of a warehouse item that has been written off"
    totalQuantity: BigDecimal
    "unitType"
    unitType: UnitType!
    "warehouse if of a warehouse item"
    warehouseId: UUID
    "warehouse name of a warehouse item"
    warehouseName: String
}

type WarehousePage implements Page {
    content: [Warehouse!]!
    pageNumber: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
}

type WarehouseResult implements RequestResult {
    "Error message in case of failure"
    errorMessage: String
    output: Warehouse
    "Result status of the transaction"
    result: TransactionResult!
    transactionId: UUID
}

type XlsReportCreationStartedNotification {
    createdDate: Instant
    id: UUID
    message: String
    type: NotificationType
}

type XlsReportGeneratedNotification {
    buttons: [NotificationButton!]
    createdDate: Instant
    id: UUID
    message: String
    type: NotificationType
}

type YandexImage {
    "image extension (e.g. jpg, png...)"
    extension: String
    externalImage: ExternalImage!
    "image height"
    height: Int
    "original image file name"
    originalFileName: String
    "image width"
    width: Int
}

type YandexMenu {
    active: Boolean!
    countOfStores: Long!
    countOfTerminals: Long!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    "menu id"
    id: UUID!
    integrationProperty: IntegrationProperty
    "amoumt of all menu items in all menu sections"
    menuItemsAmount: Long
    "menu sections that current menu has inside"
    menuSections: [MenuSection!]
    "menu name"
    name: String!
    "organization to which the menu belongs"
    organization: Organization!
    "sort number"
    position: Int
    "store to which the menu belongs"
    storeId: UUID!
    "menu type"
    type: MenuType
    url: String
}

type YandexMenuCategory {
    available: Boolean!
    "id from yandex eats"
    eatsId: Long!
    items: [YandexMenuItem!]
    name: String!
}

type YandexMenuItem {
    available: Boolean!
    decimalPrice: BigDecimal!
    description: String!
    "id from yandex eats"
    eatsId: Long!
    images: [YandexImage!]
    name: String!
    price: BigDecimal!
    weight: String
}

type YandexPromo {
    discount: BigDecimal!
    type: YandexPromoType!
}

"Subscription to tariff"
type _Subscription {
    active: Boolean!
    "Acitive Service Plan Option"
    activeServicePlanOption: ServicePlanOption
    "The time when the subscription will be renewed. The format is yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    endDate: Instant
    "Subscription id"
    id: UUID
    "Next payment"
    nextPayment: PaymoPayment
    "Rate"
    servicePlan: ServicePlan!
    "Subscription start time. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    startDate: Instant
    status: SubscriptionStatus!
    trialPeriod: Boolean!
    "Trial period duration. ISO 8601 format: P (n) Y (n) M (n) DT (n) H (n) M (n) S"
    trialPeriodDuration: String!
    "Trial period expiration time. Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    trialPeriodEndDate: Instant
    "The time the trial period started. The format is yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    trialPeriodStartDate: Instant
}

enum AbcReportV2SortField {
    NAME
    """

    REVENUE_PERCENT_OUT_OF_TOTAL,
    PROFIT_PERCENT_OUT_OF_TOTAL,
    """
    PRODUCT_TYPE
    PROFIT
    PROFIT_PERCENT
    QUANTITY
    REVENUE
    UNIT_TYPE
}

"Project interaction actions"
enum Action {
    EDIT
    READ
}

enum AgentSign {
    ANOTHER
    ATTORNEY
    BANK_PAYING_AGENT
    BANK_PAYING_SUBAGENT
    COMMISSION_AGENT
    NONE
    PAYING_AGENT
    PAYING_SUBAGENT
}

enum Aligment {
    CENTER
    LEFT
    RIGHT
}

enum AllArrivalDocumentsPageableV2SortField {
    CREATION_DATE
    DATE
    DOC_NUMBER
    ORGANIZATION
    STATUS
    SUPPLIER
    TOTAL_AMOUNT
    WAREHOUSE
}

enum AllInventoryDocumentsPageableV2SortField {
    DATE
    DOC_NUMBER
    INVENTORY_TYPE
    STATUS
    TOTAL_AMOUNT_DELTA
    WAREHOUSE
}

enum AllLeavingDocumentsPageableV2SortField {
    CREATION_DATE
    DATE
    DOC_NUMBER
    ORGANIZATION
    STATUS
    TOTAL_AMOUNT
    WAREHOUSE
}

enum AllMoveDocumentsPageableSortField {
    CREATION_DATE
    DATE
    DOC_NUMBER
    ORGANIZATION
}

enum AllMoveDocumentsPageableV2SortField {
    CREATION_DATE
    DATE
    DOC_NUMBER
    ORGANIZATION
    STATUS
    TOTAL_AMOUNT
    WAREHOUSE_FROM
    WAREHOUSE_TO
}

enum AllSuppliersPageableSortField {
    COMPANY_NAME
    CONTACT_POINT
    TOTAL_COSTS
    TYPE
}

enum AppliedDiscountType {
    ITEM_DISCOUNT
    LOYALTY
    ORDER_DISCOUNT
}

enum BarcodeType {
    CODABAR
    CODE128
    CODE39
    CODE93
    EAN13
    EAN8
    GS1_128
    ITF
    ITF14
    PDF417
    QR
    UPCA
    UPCE
}

enum BillStatus {
    CLOSED
    EXPIRED
    OPEN
}

enum BonusProgramType {
    DECREASE
    INCREASE
}

"Type of entity bound to discount"
enum BoundEntityType {
    "Whole catalog"
    CATALOG
    "Product in catalog"
    PRODUCT
    "Section of catalog"
    SECTION
}

enum CatalogEntityType {
    CATALOG
    PRODUCT
    SECTION
    STOCK_UNIT
    STORE @deprecated(reason: "No longer supported")
}

enum CategoryReportSortField {
    CATEGORY_NAME
    FOOD_COST
    KILOGRAM_QUANTITY
    LITER_QUANTITY
    ORDERS_QUANTITY
    PIECE_QUANTITY
    PRIME_PRICE
    PROFIT
    REVENUE
    TAX
}

enum ColorSection {
    COLOR_V1
    COLOR_V10
    COLOR_V2
    COLOR_V3
    COLOR_V4
    COLOR_V5
    COLOR_V6
    COLOR_V7
    COLOR_V8
    COLOR_V9
}

enum ConsolidatedReportSortFields {
    AVERAGE_CHECK
    DISCOUNT
    ORDERS_COUNT
    PROFIT
    REVENUE
    TIMESTAMP
}

enum CorrectionReceiptType {
    BUY_CORRECTION
    BUY_RETURN_CORRECTION
    SELL_CORRECTION
    SELL_RETURN_CORRECTION
}

enum CorrectionType {
    INSTRUCTION
    SELF
}

enum CustomerGroupsSortField {
    CUSTOMERS_COUNT
    NAME
}

enum DateGrouping {
    DAY
    HOUR
    MONTH
}

"Day of week"
enum DayOfWeek {
    FRIDAY
    MONDAY
    SATURDAY
    SUNDAY
    THURSDAY
    TUESDAY
    WEDNESDAY
}

enum DeviceType {
    PHONE
    TABLET
}

enum DiscountBasis {
    ORDER
    ORDER_ITEM
}

"Type of discount"
enum DiscountType {
    "Type for product combos (e.g. 15% discount for 2 burgers and 1 cola)"
    COMBO
    "Type for products made free on certain quantity (e.g. 3rd coffee free)"
    COUNTED
    "Default type"
    STANDARD
}

enum DocumentType {
    BSO
    BSO_CORRECTION
    CLOSE_FN
    CLOSE_SHIFT
    CORRECTION
    EXCHANGE_STATUS
    OPEN_SHIFT
    OPERATOR_CONFIRMATION
    RECEIPT
    REGISTRATION
    REREGISTRATION
}

enum EmployeeSubscriptionType {
    CREATED
    REMOVED
    TARGET_PERMISSION_CHANGED
    UPDATED
}

enum FFDVersion {
    FFD_1_0_5
    FFD_1_1
    UNKNOWN
}

enum FiscalReceiptType {
    BUY
    BUY_RETURN
    SELL
    SELL_RETURN
}

enum FiscalStatus {
    FiscalizationError
    NotFiscal
    SuccessfullyFiscalized
}

enum GenderType {
    FEMALE
    MALE
}

enum GetAnalyticsWarehouseItemMoveHistoriesDetailsSortField {
    ARRIVAL
    CATEGORY
    MOVEMENT_DATE
    PRIME_PRICE_AT_END_OF_PERIOD
    PRIME_PRICE_AT_START_OF_PERIOD
    PRODUCT_TYPE
    QUANTITY_AT_END_OF_PERIOD
    QUANTITY_AT_START_OF_PERIOD
    STOCK_UNIT_NAME
    WAREHOUSE
    WRITTEN_OFF
}

enum GraphQLMethodType {
    MUTATION
    QUERY
}

"Identity type (login types)"
enum IdentityType {
    EMAIL
    PHONE
}

enum InventoryType {
    FULL
    PARTIAL
}

enum LoyaltyPointsTransactionType {
    DECREASE
    INCREASE
}

"Sort direction"
enum MarketingSortDirection {
    "Ascending (0-9, A-Z)"
    ASC
    "Descending (9-0, Z-A)"
    DESC
}

enum MenuElementType {
    ITEM
    SECTION
}

"Menu type"
enum MenuType {
    DEFAULT
    DELIVERY
    ONLINE
}

enum ModifierEntityType {
    PRODUCT
    SECTION
}

enum ModifierType {
    STOCK_UNIT_MODIFIER
    TEXT_MODIFIER
}

enum NotificationType {
    ALERT
    DEFAULT
    INFORMATION
    SUCCESS
    SYSTEM @deprecated(reason: "Use DEFAULT")
    WARNING @deprecated(reason: "Use INFORMATION")
}

enum OrderItemStatus {
    CANCELLED
    IN_KITCHEN
    NEW
    READY
    SUBMITTED
}

enum OrderState {
    CANCELED
    CLOSED
    NEW
    REFUNDED
}

enum OrderStatus {
    CLOSED
    NEW
}

enum OrderType {
    DELIVERY
    HERE
    TAKEAWAY
}

enum OrdersReportSortField {
    CURRENCY
    DATE
    FISCAL_STATUS
    GUESTS_COUNT
    INCOME_AMOUNT
    ITEMS_COUNT
    ORDER_AMOUNT
    ORDER_NUMBER
    PAYMENTS_AMOUNT
    PAY_SYSTEM_NAMES
    SHIFT
    STATUS
    TAX_AMOUNT
}

"Pay system icon type"
enum PaySystemIcon {
    CARD
    CASH
    DELIVERY_CLUB
    GUEST
    RUBLE
    YANDEX_EATS
}

enum PaySystemReportSortField {
    AVERAGE_CHECK
    GUESTS_COUNT
    ORDERS_QUANTITY
    PAY_SYSTEM_NAME
    REVENUE
}

enum PaySystemType {
    CARD
    CASH
    VIRTUAL
}

enum PaymentStatus {
    CANCELED
    NEW
    PAYED
    RETURN
}

enum PaymentType {
    CASH
    CREDIT
    ELECTRONICALLY
    OTHER
    PREPAID
}

"Type of discount activity period"
enum PeriodType {
    "Discount is active permanently"
    PERMANENT
    "Discount is active in certain hours of some weekdays (e.g. from monday to sunday from 12:00 to 16:00)"
    SCHEDULED
    "Discount is active for certain period of days (e.g. from February 23rd to March 8th)"
    TEMPORARY
}

enum PointTransactionFactCore {
    CREDIT
    DEBIT
}

enum PointTransactionType {
    DECREASE_POINTS
    INCREASE_POINTS
}

"Тип позиции"
enum PositionTypeCode {
    "Подакцизный товар (код 2)"
    EXCISABLE_PRODUCT
    "АТМ (код 31)"
    EXCISABLE_PRODUCT_MARKED
    "АТНМ (код 30)"
    EXCISABLE_PRODUCT_NOT_MARKED
    "Товар (код 1)"
    PRODUCT
    "ТМ (код 33)"
    PRODUCT_MARKED
    "ТНМ (код 32)"
    PRODUCT_NOT_MARKED
    "Услуга (код 4)"
    SERVICE
}

enum PositionUnitType {
    CENTIMETER
    CUBIC_METER
    DAY
    DECIMETER
    GIGABYTE
    GIGACALORIE
    GRAM
    HOUR
    KILOBYTE
    KILOGRAM
    KILOWATT_HOUR
    LITER
    MEGABYTE
    METER
    MILLILITER
    MINUTE
    OTHER
    PIECE
    SECOND
    SQUARE_CENTIMETER
    SQUARE_DECIMETER
    SQUARE_METER
    TERABYTE
    TON
}

enum ProductReportSortField {
    DISCOUNT
    PRIME
    PRODUCT_NAME
    PRODUCT_TYPE
    PROFIT
    REVENUE
    SALES
    UNIT_TYPE
}

enum ProductType {
    INGREDIENT
    MODIFIER
    PRODUCT
    SEMIPRODUCT
}

enum PromotionProgramSortField {
    ACTIVE
    NAME
    PERIOD
    PROMOTION_TYPE
}

enum PromotionType {
    BONUS_DECREASE
    BONUS_INCREASE
    DISCOUNT
}

enum ReRegistrationReason {
    AUTONOMUS_MODE_DISABLING
    AUTONOMUS_MODE_ENABLING
    BSO_MODE_DISABLING
    BSO_MODE_ENABLING
    DEVICE_MARK_CHANGING
    DEVICE_MODEL_VERSION_CHANGING
    FFD_VERSION_CHANGING
    FN_CHANGING
    GAMBLING_MODE_DISABLING
    GAMBLING_MODE_ENABLING
    LOTTERY_MODE_DISABLING
    LOTTERY_MODE_ENABLING
    MANUAL_MODE_DISABLING
    MANUAL_MODE_ENABLING
    OFD_CHANGING
    ONLINE_MODE_DISABLING
    ONLINE_MODE_ENABLING
    ORGANIZATION_NAME_CHANGING
    OTHER
    STORE_ADDRESS_CHANGING
    TAX_LIST_CHANGING
}

enum ReceiptPositionType {
    EXCISABLE_PRODUCT
    EXCISABLE_PRODUCT_MARKED
    EXCISABLE_PRODUCT_NOT_MARKED
    PRODUCT
    PRODUCT_MARKED
    PRODUCT_NOT_MARKED
    SERVICE
}

enum RegistrationModeSign {
    AUTONOMOUS
    ENCRYPTION
    EXCISABLE_GOODS
    GAMBLING
    INTERNET_ONLY
    IN_MACHINE
    LOTTERY
    PRINTER_IN_MACHINE
    PROVIDE_SERVICES
    STRICT_FORMS_ONLY
}

"User group role codes"
enum RoleCode {
    ADMIN
    CASHIER
    MANAGER
}

enum Scale {
    ASPECT_FILL
}

enum ScheduleType {
    DELIVERY_TIME
    TAKEAWAY_TIME
    WORKING_TIME
}

"Project interaction scopes"
enum Scope {
    ACCOUNT
    ANALYTICS
    CATALOG
    DELIVERY
    DISCOUNT
    EMPLOYEE
    GOAL
    IMAGE
    INVITATION
    KITCHEN
    LOYALTY
    MENU
    ORDER
    ORDER_PAYMENT
    ORGANIZATION
    RECEIPT
    SERVICE_PLAN
    STORE
    SUBSCRIPTION
    TASK
    TERMINAL_SETTINGS
    UNACCEPTED_INVITATION
    WAREHOUSE
    WAREHOUSE_DOCUMENT
    YANDEX
    YANDEX_MENU
    YANDEX_ORDER
    YANDEX_RESTAURANT @deprecated(reason: "No longer supported")
}

"""

Sign in type:
ERP: will send confirmation code if such user does not exists, or user has no password
POS: will not send any confirmation code, will check that user has menu in any of his organizations
"""
enum SignInType {
    ERP
    POS
}

enum SignerBase {
    "устав"
    CHARTER
    "доверенность"
    PROCURATION
}

enum Sno {
    DEFAULT
    ESN
    OSN
    PATENT
    USN_INCOME
    USN_INCOME_OUTCOME
}

"Sort direction"
enum SortDirection {
    "Ascending (0-9, A-Z)"
    ASC
    "Descending (9-0, Z-A)"
    DESC
}

enum Stage {
    CANCELED
    COOKING
    COURIER_IS_PICKUP
    COURIER_ON_THE_SPOT
    COURIER_ON_THE_WAY
    DELIVERED
    READY_FOR_PICKUP
    WAITING_FOR_APPROVE
}

"Status of production task"
enum Status {
    CANCELED
    CLOSED
    DONE
    IN_PROGRESS
    NEW
}

"Document status"
enum StatusDocument {
    CONFIRMED
    PENDING
    REJECTED
}

enum StatusPointTransaction {
    CANCELED
    COMPLETED
    INVALID
    PENDING
    REFUSED
}

enum StoreType {
    KAFE
    RESTAURANT
    SHOP
}

enum SubscriptionStatus {
    AWAITING_PAYMENT
    AWAITING_RETRY
    CANCELLED
    ENABLED
}

enum TableBookingStatus {
    CANCELED
    CONFIRMED
    PENDING
}

enum TaxSystem {
    ESN
    OSN
    PATENT
    USN_INCOME
    USN_INCOME_OUTCOME
}

enum TaxType {
    NONE
    VAT0
    VAT10
    VAT110
    VAT120
    VAT20
}

enum TermsDeviceType {
    ANY
    PHONE
    TABLET
}

enum TextWrap {
    CHARS
    NONE
    WORDS
}

"Transaction results"
enum TransactionResult {
    ERROR
    SUCCESS
}

enum TransactionStatus {
    ABORTED
    APPROVED
    CONNECTION_ERROR
    REJECTED
    UNDEFINED_ERROR
    UNKNOWN
}

enum TrueApiCodeFailedCheckCodeType {
    TM_CHECK_ERROR
    TM_CRYPTO_FAILED
    TM_EXPIRED
    TM_NOT_OWNED
    TM_NOT_UTILIZED
    TM_STRUCT_INVALID
    TM_UNREALIZABLE
}

"Type for overview query"
enum Type {
    CATALOG
    MENU
    STORE
    WAREHOUSE
}

"Document type"
enum TypeDocument {
    ARRIVAL
    CANCELLATION_RESERVATION
    INVENTORY
    LEAVING
    LEAVING_BY_ORDER
    MOVE
    RETURN
}

"Legal type of supplier"
enum TypeSupplier {
    "Legal person (юридическое лицо)"
    LEGAL_PERSON
    "Natural person (физическое лицо)"
    NATURAL_PERSON
}

enum TypeTask {
    DARK
    LIGHT
}

"constants"
enum UnitType {
    GRAM
    KILOGRAM
    LITER
    MILLILITER
    NONE
    PIECE
}

enum VatType {
    DEFAULT
    NONE
    VAT_0
    VAT_10
    VAT_110
    VAT_120
    VAT_20
}

"Event in warehouse"
enum WarehouseItemEvent {
    ARRIVAL
    NONE
    RECALCULATION
    WRITE_OFF
}

enum WarehouseItemLeftoverSortFields {
    LAST_ARRIVAL_DATE
    NAME
    PRIME_PRICE_AMOUNT_VALUE
    QUANTITY
    SECTION_NAME
    TOTAL_AMOUNT
    TYPE
    UNIT_TYPE
    WAREHOUSE_NAME
}

"Reason of event in warehouse"
enum WarehouseItemReasonEvent {
    ARRIVAL_DOCUMENT
    INVENTORY_DOCUMENT
    LEAVING_DOCUMENT
    MOVE_DOCUMENT
    NONE
    PACK
    RETURN
    RETURN_DOCUMENT
    SOLD
    UNPACK
}

enum WarehousesPageableSortField {
    ADDRESS
    NAME
}

enum YandexPromoType {
    FIXED
    GIFT
    PERCENTAGE
}

"An arbitrary precision signed decimal"
scalar BigDecimal

"An RFC-3339 compliant DateTime Scalar"
scalar DateTime

"A file part in a multipart request"
scalar FileUpload

scalar Instant

scalar LocalDate

"Java 8 LocalDateTime as scalar."
scalar LocalDateTime

"Java 8 LocalTime as scalar."
scalar LocalTime

"A 64-bit signed integer"
scalar Long

scalar UUID

scalar Void

input AbcReportInput {
    dateRange: DateRangeInput!
    search: String
    sectionIds: [UUID!]
    storeIds: [UUID!]!
    types: [ProductType!]
}

input AbcReportPageableFilterInput {
    "start & end of a period (yyyy-MM-dd'T'hh:mm:ss.ssssssZ)"
    dateRangeInput: DateRangeInput!
    "list of stores to filter"
    storeIds: [UUID!]
    "list of terminals to filter"
    terminalIds: [UUID!]
}

input AbcReportV2Sort {
    direction: SortDirection
    field: AbcReportV2SortField
}

input AbstractDocumentFilterInput {
    dateFrom: Instant
    dateTo: Instant
    statuses: [StatusDocument!]
}

input AbstractTaskFilterInput {
    kitchenWorkshopId: UUID!
    statuses: [Status!]
    typeTasks: [TypeTask!]
}

"Account updating input"
input AccountInput {
    "User avatar"
    image: ImageInput
    "Mark that user passed nomia welcome tutorial"
    onboarded: Boolean
}

input AcquiringDataInput {
    amount: AmountDataInput!
    authCode: String!
    expDate: Instant!
    hostDateTime: Instant!
    merchantId: String!
    orgDateTime: Instant
    pan: String!
    receiptData: String!
    responseCode: String!
    responseMessage: String!
    rrn: String!
    stan: Int!
    terminalId: String!
    transactionStatus: TransactionStatus!
    trxId: Int!
}

"Period when discount is active"
input ActivityPeriodInput {
    "Periods of time within days when discount is active (for `periodType == SCHEDULED`)"
    dailyPeriods: [DailyPeriodInput!]
    """

    !!! @deprecated Use dailyPeriods instead
    Days of week when discount is active (for `periodType == SCHEDULED`)
    """
    daysOfWeek: [DayOfWeek!]
    "Activity period ID"
    id: UUID
    "Maximum date when discount is active (for `periodType == TEMPORARY`)"
    maxDate: LocalDate
    """

    !!! @deprecated Use dailyPeriods instead
    Maximum time of day when discount is active (for `periodType == SCHEDULED`)
    """
    maxTime: LocalTime
    "Minimal date when discount is active (for `periodType == TEMPORARY`)"
    minDate: LocalDate
    """

    !!! @deprecated Use dailyPeriods instead
    Minimal time of day when discount is active (for `periodType == SCHEDULED`)
    """
    minTime: LocalTime
    "Type"
    periodType: PeriodType!
}

input AddAddonInput {
    addonId: UUID!
    quantity: Int!
}

input AllArrivalDocumentsPageableV2Sort {
    direction: SortDirection
    field: AllArrivalDocumentsPageableV2SortField
}

input AllInventoryDocumentsPageableV2Sort {
    direction: SortDirection
    field: AllInventoryDocumentsPageableV2SortField
}

input AllLeavingDocumentsPageableV2Sort {
    direction: SortDirection
    field: AllLeavingDocumentsPageableV2SortField
}

input AllMoveDocumentsPageableSort {
    direction: SortDirection
    field: AllMoveDocumentsPageableSortField
}

input AllMoveDocumentsPageableV2Sort {
    direction: SortDirection
    field: AllMoveDocumentsPageableV2SortField
}

input AllSuppliersPageableSort {
    direction: SortDirection
    field: AllSuppliersPageableSortField
}

"Amount data input"
input AmountDataInput {
    "Value of money"
    amountValue: BigDecimal!
    "Money currency"
    currencyUnit: String!
}

input AnalyticsWarehouseItemMoveHistoriesDetailsFilterInput {
    dateFrom: LocalDate
    dateTo: LocalDate
    productTypes: [ProductType!]
    sectionIds: [UUID!]
    skuName: String
    warehouseIds: [UUID!]
}

input AnalyticsWarehouseItemMoveHistoryDetailsFilterInput {
    dateFrom: LocalDate
    dateTo: LocalDate
    statuses: [WarehouseItemReasonEvent!]
    stockUnitId: UUID
    warehouseIds: [UUID!]
}

input AnalyticsWarehouseItemMoveHistoryFilterInput {
    dateFrom: LocalDate!
    dateTo: LocalDate!
    statuses: [WarehouseItemReasonEvent!]!
    stockUnitId: UUID!
    warehouseIds: [UUID!]!
}

"Request a token for an external device / application"
input ApplicationInfoInput {
    "Token name"
    name: String
    "Id of the store for which the token is requested"
    storeId: UUID!
    "Id of the terminal for which the token is requested"
    terminalId: UUID!
}

input ApplicationInfoInputV2 {
    "Device model"
    deviceModel: String
    "Device type"
    deviceType: DeviceType!
    "Unique key of the device"
    deviceUniqueKey: String!
    "Token name"
    name: String
    "Id of the store for which the token is requested"
    storeId: UUID!
    "Id of the terminal for which the token is requested"
    terminalId: UUID!
}

"Discount applied to the order"
input AppliedDiscountInput {
    "whether discount sets automatically"
    automatic: Boolean
    "whether discount is combined with others discounts"
    combined: Boolean
    "discount Id"
    discountId: UUID!
    "discount name"
    discountName: String
    "discount type"
    discountType: DiscountType
    "applied discount id"
    id: UUID
    "discount percent"
    percent: BigDecimal
}

input AppliedModifierGroupInput {
    entityId: UUID!
    entityName: String!
    entityType: ModifierEntityType!
    maxValue: Int!
    minValue: Int!
    modifierGroupId: UUID!
    name: String!
    required: Boolean!
    type: ModifierType!
}

input AppliedModifierInput {
    amount: AmountDataInput
    id: UUID!
    modifierGroup: AppliedModifierGroupInput!
    modifierId: UUID!
    name: String!
    positionTypeCode: PositionTypeCode
    primePrice: AmountDataInput
    quantity: MeasureDataInput
    resultAmount: AmountDataInput
    salePrice: AmountDataInput
    sno: Sno
    stockUnitId: UUID
    type: ModifierType!
    unitAmount: AmountDataInput
    unitQuantity: MeasureDataInput
    vatType: VatType
}

input ApplyOrderDiscountInput {
    "discountAmount OR loyaltyAmount"
    amount: BigDecimal!
    "applied discountId OR applied loyaltyId"
    appliedId: UUID!
    "discountId OR loyaltyId"
    id: UUID!
    "discountName OR loyaltyName"
    name: String!
    "type to qualify given entity"
    type: AppliedDiscountType!
}

"Arrival document data"
input ArrivalDocumentCreateInput {
    "Date of arrival"
    date: Instant
    "Description"
    description: String
    "Arrived items"
    documentItems: [DocumentItemInput!]
    "ID of supplier from which items arrived"
    supplierId: UUID!
    "ID of warehouse to which items arrived"
    toWarehouseId: UUID!
}

"Arrival document data"
input ArrivalDocumentUpdateInput {
    "Date of arrival"
    date: Instant
    "Description"
    description: String
    "Arrived items"
    documentItems: [DocumentItemInput!]
    "Arrival document ID"
    id: UUID!
    "ID of supplier from which items arrived"
    supplierId: UUID!
    "ID of warehouse to which items arrived"
    toWarehouseId: UUID!
}

input BarcodeInput {
    code: String!
    id: UUID
}

input BonusProgramCreateInput {
    bonusProgramType: BonusProgramType!
    pointPrice: PointPriceInput!
    promotionProgram: PromotionProgramCreateInput!
}

input BonusProgramUpdateInput {
    id: UUID!
    pointPrice: PointPriceInput
    promotionProgram: PromotionProgramUpdateInput
}

input CalculatePointsInput {
    customerId: UUID!
    items: [ItemCalculatePointsInput!]!
    orderPrice: BigDecimal!
    storeId: UUID!
}

input CancelAddonInput {
    addonId: UUID!
    quantity: Int!
}

"Catalog input data"
input CatalogCreateInput {
    "Catalog active"
    active: Boolean
    "Catalog name"
    name: String!
    "Position type for catalog"
    positionTypeCode: PositionTypeCode
    "Catalog sort"
    sort: Int
    "TaxProfile for catalog"
    taxProfile: TaxProfileCreateInput
}

"Section color input data"
input CatalogSectionColorInput {
    "Color code in hex"
    code: String!
    "Color name"
    name: String
}

"Section input data"
input CatalogSectionCreateInput {
    "Section active"
    active: Boolean
    "Id of catalog which the section belongs to"
    catalogId: UUID!
    "Section color"
    color: CatalogSectionColorInput!
    "Section image"
    image: ImageInput
    "Section name"
    name: String!
    "Id of parent section which the section belongs to"
    parentSectionId: UUID
    "Position type for section"
    positionTypeCode: PositionTypeCode
    "Section sort"
    sort: Int
    "TaxProfile for section"
    taxProfile: TaxProfileCreateInput
}

"Section input data"
input CatalogSectionCreateInputV2 {
    "Section active"
    active: Boolean
    "Id of catalog which the section belongs to"
    catalogId: UUID!
    "Section image"
    imageId: UUID
    "Section name"
    name: String!
    "Id of parent section which the section belongs to"
    parentSectionId: UUID
    "Position type for section"
    positionTypeCode: PositionTypeCode
    "Section sort"
    sort: Int
    "TaxProfile for section"
    taxProfile: TaxProfileCreateInput
}

"Filter object for catalog sections"
input CatalogSectionFilterInput {
    "Catalog ID"
    catalogId: UUID
    "Search substring within section name"
    depthLevel: Int
    "Parent section ID"
    parentSectionId: UUID
    search: String
}

input CatalogSectionUpdateInput {
    "Section active"
    active: Boolean
    "Id of catalog which the section belongs to"
    catalogId: UUID!
    "Section color"
    color: CatalogSectionColorInput!
    "Section id"
    id: UUID!
    "Section image"
    image: ImageInput
    "Section name"
    name: String!
    "Id of parent section which the section belongs to"
    parentSectionId: UUID
    "Position type for section"
    positionTypeCode: PositionTypeCode
    "Section sort"
    sort: Int
    "TaxProfile for section"
    taxProfile: TaxProfileCreateInput
}

input CatalogSectionUpdateInputV2 {
    "Section active"
    active: Boolean
    "Id of catalog which the section belongs to"
    catalogId: UUID!
    "Section color"
    colorSection: ColorSection!
    "Section id"
    id: UUID!
    "Section image"
    imageId: UUID
    "Section name"
    name: String!
    "Id of parent section which the section belongs to"
    parentSectionId: UUID
    "Position type for section"
    positionTypeCode: PositionTypeCode
    "Section sort"
    sort: Int
    "TaxProfile for section"
    taxProfile: TaxProfileCreateInput
}

"Catalog techCard input data"
input CatalogTechCardInput {
    "TechCard ID (only when update)"
    id: UUID
    "List of techCard items"
    items: [CatalogTechCardItemInput!]
    "description of the cooking process"
    processOfCooking: String
}

"Catalog techCard item input data"
input CatalogTechCardItemInput {
    "Brutto quantity of item in specified units"
    brutto: BigDecimal!
    "Measurement unit type"
    bruttoUnit: UnitType!
    "Netto quantity of item in specified units"
    netto: BigDecimal!
    "ID of contained stockUnit"
    stockUnitId: UUID!
    techCardItemId: UUID
}

input CatalogUpdateInput {
    "Catalog active"
    active: Boolean
    "Catalog ID"
    id: UUID!
    "Catalog name"
    name: String!
    "Position type for catalog"
    positionTypeCode: PositionTypeCode
    "Catalog sort"
    sort: Int
    "TaxProfile for catalog"
    taxProfile: TaxProfileCreateInput
}

input CategoryReportInput {
    dateRange: DateRangeInput!
    search: String
    sectionIds: [UUID!]
    storeIds: [UUID!]
}

input CategoryReportSort {
    direction: SortDirection
    field: CategoryReportSortField
}

"Account password change request input"
input ChangePasswordInput {
    "New account password"
    newPassword: String!
    "Old account password"
    oldPassword: String!
}

input ChartInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
    terminalIds: [UUID!]
}

input ClientInput {
    email: String
    name: String
    phone: String
    vatin: String
}

"Support control claim confirmation input"
input ConfirmSupportControlClaimInput {
    organizationId: UUID!
    password: String!
}

input ConsolidatedReportInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input ConsolidatedReportSort {
    direction: SortDirection
    field: ConsolidatedReportSortFields
}

input ConvertableUnitInput {
    convertableQuantity: BigDecimal!
    convertableUnitType: UnitType!
}

input CoordinatesInput {
    "In case of geo pos: longitude (e.g. of Moscow is 55.75000)"
    latitude: Float!
    "In case of geo pos: latitude (e.g. of Moscow is 37.62100)"
    longitude: Float!
}

input CorrectionDocumentInput {
    checksum: String
    correctionBaseDate: DateTime
    correctionBaseName: String
    correctionBaseNumber: String
    correctionType: CorrectionType
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int!
    documentType: DocumentType
    electronically: Boolean
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String!
    items: [ReceiptItemWrapperInput]
    ofd: OfdInput
    ofdTicket: OfdTicketInput
    operator: OperatorInput
    orderId: UUID
    organizationName: String
    organizationVatin: String
    payments: [PaymentInput]
    receiptType: CorrectionReceiptType
    registrationNumber: String
    roundTotal: Boolean
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
}

"Employee creation input"
input CreateEmployeeInput {
    "Describes employee accessibility"
    active: Boolean!
    "Living address"
    address: String
    "Date of birth (ISO-8601)"
    dateOfBirth: Instant
    "Date of employment (ISO-8601)"
    dateOfEmployment: Instant
    "Employee alias name"
    firstName: String!
    lastName: String!
    "Medical book expire date (ISO-8601)"
    medicalBookExpiresAt: Instant
    middleName: String
    "Employee access pin-code"
    pin: String
    "СНИЛС"
    snils: String
    "Usergroup membership"
    userGroups: [UserGroupInput!]!
    "ИНН"
    vatin: String
    "Contact email"
    workEmail: String!
    "Contact phone"
    workPhone: String
}

"Employee invitation create input"
input CreateEmployeeInvitationInput {
    "Employee willing for employement"
    employeeId: UUID!
    "Invitation expire date (ISO-8601)"
    expiresAt: Instant
}

input CreateModifierGroupInput {
    "there is no concept of activity at the moment"
    active: Boolean
    maxValue: Int
    minValue: Int
    modifiers: [CreateModifierInput!]
    name: String!
    productIds: [UUID!]
    required: Boolean
    sort: Int
    type: ModifierType
}

input CreateModifierInput {
    stockUnitModifier: CreateStockUnitModifierInput
    textModifier: CreateTextModifierInput
}

"Organization creation input"
input CreateOrganizationInput {
    "Currency unit e.g. RUB"
    currencyUnit: String
    "Name of new organization"
    name: String
}

"Organization invitation creation input"
input CreateOrganizationInvitationInput {
    "Describes active state for this invitation"
    active: Boolean
    "Name of invitation"
    name: String!
}

input CreateStockUnitModifierInput {
    name: String!
    pinned: Boolean!
    sort: Int!
    stockUnitId: UUID!
}

input CreateTextModifierInput {
    name: String!
    pinned: Boolean!
    sort: Int!
}

input CreditLoyaltyCreateInput {
    active: Boolean!
    beginsAt: LocalDate
    customerGroupIds: [UUID!]
    description: String
    endsAt: LocalDate
    imageId: UUID
    name: String!
    pointPrice: BigDecimal!
    storeBindings: [LoyaltyStoreBindingInput!]
}

"CreditLoyalty"
input CreditLoyaltyFilterInput {
    search: String
    storeIds: [UUID!]
    withoutStoreBindings: Boolean
}

input CreditLoyaltyUpdateInput {
    active: Boolean
    beginsAt: LocalDate
    customerGroupIds: [UUID!]
    description: String
    endsAt: LocalDate
    id: UUID!
    imageId: UUID
    name: String
    pointPrice: BigDecimal
    storeBindings: [LoyaltyStoreBindingInput!]
}

input CustomerAddressInput {
    baseAddress: String!
    door: String
    doorCode: String
    flatNumber: String
    floor: Int
    floorString: String
}

input CustomerCreateInput {
    address: CustomerAddressInput
    cardNumber: String
    comment: String
    dateOfBirth: LocalDate
    firstName: String!
    gender: GenderType
    groups: [UUID!]
    lastName: String
    phoneNumber: String
}

"Customer"
input CustomerFilterInput {
    groupIds: [UUID!]
    search: String
    withoutGroups: Boolean
}

input CustomerForCurrentDayWidgetInput {
    customerId: UUID!
}

input CustomerGroupCreateInput {
    description: String
    name: String!
    storeId: UUID
}

"CustomerGroup"
input CustomerGroupFilterInput {
    search: String
    storeIds: [UUID!]
}

input CustomerGroupUpdateInput {
    description: String
    id: UUID!
    name: String
    storeId: UUID
}

input CustomerGroupsSort {
    direction: SortDirection
    field: CustomerGroupsSortField
}

input CustomerOrdersInput {
    customerId: UUID!
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input CustomerSnapshotInput {
    address: CustomerAddressInput
    cardNumber: String
    dateOfBirth: LocalDate
    firstName: String!
    id: UUID!
    lastName: String
    phoneNumber: String
}

input CustomerUpdateInput {
    address: CustomerAddressInput
    cardNumber: String
    comment: String
    dateOfBirth: LocalDate
    firstName: String
    gender: GenderType
    groups: [UUID!]
    id: UUID!
    lastName: String
    phoneNumber: String
}

input CustomerUpdateInputV2 {
    addGroups: [UUID!]
    address: CustomerAddressInput
    cardNumber: String
    comment: String
    dateOfBirth: LocalDate
    firstName: String
    gender: GenderType
    id: UUID!
    lastName: String
    phoneNumber: String
    removeGroups: [UUID!]
}

"Timespan within day when discount is active"
input DailyPeriodInput {
    "Day of week for which the activity period is set"
    dayOfWeek: DayOfWeek!
    "Maximum time of day when discount is active"
    maxTime: LocalTime!
    "Minimal time of day when discount is active"
    minTime: LocalTime!
}

input DarkTaskFilterInput {
    statuses: [Status!]
}

"Dark task data"
input DarkTaskInput {
    "Dark task ID"
    id: UUID
    "ID of warehouse which supplies items for this task"
    inWarehouseId: UUID
    "ID of kitchen workshop this task has been assigned to"
    kitchenWorkshopId: UUID!
    "ID of warehouse which stores items made during this task"
    outWarehouseId: UUID
    "ID of store this task is for"
    storeId: UUID!
    "Items created with this task"
    taskItems: [TaskItemInput!]
}

input DateRangeInput {
    dateFrom: LocalDate!
    dateTo: LocalDate!
}

input DateTimeRange {
    from: DateTime
    to: DateTime
}

input DebitLoyaltyCreateInput {
    active: Boolean!
    beginsAt: LocalDate
    customerGroupIds: [UUID!]
    description: String
    endsAt: LocalDate
    imageId: UUID
    maxPercentage: Int!
    name: String!
    pointPrice: BigDecimal!
    storeBindings: [LoyaltyStoreBindingInput!]
}

"DebitLoyalty"
input DebitLoyaltyFilterInput {
    search: String
    storeIds: [UUID!]
    withoutStoreBindings: Boolean
}

input DebitLoyaltyUpdateInput {
    active: Boolean
    beginsAt: LocalDate
    customerGroupIds: [UUID!]
    description: String
    endsAt: LocalDate
    id: UUID!
    imageId: UUID
    maxPercentage: Int
    name: String
    pointPrice: BigDecimal
    storeBindings: [LoyaltyStoreBindingInput!]
}

"Shipping Information"
input DeliveryInfoInput {
    change: AmountDataInput
    "Comment"
    comment: String
    deliveryAmount: AmountDataInput!
    """

    The time by which the order should be delivered in the yyyy-MM-dd'T'HH:mm:ss.SS'Z'format.
    If NULL, it will be delivered as soon as possible.
    """
    deliveryDate: Instant
    "Delivery address"
    fullAddress: String!
    "latitude (e.g. of Moscow is 55.75000)"
    latitude: Float!
    "longitude (e.g. of Moscow is 37.62100)"
    longitude: Float!
    "Number of guests for whom the order will be created"
    personCount: Int!
}

"Binding of discount either to catalog, section or product"
input DiscountBindingInput {
    "Amount of items in cart, which belong to entity from this binding, for `discountType == COMBO` to be applied"
    amount: BigDecimal
    "ID of bound entity from catalog"
    entityId: UUID!
    "Type of bound entity"
    entityType: BoundEntityType!
    "Discount binding ID"
    id: UUID
}

"Discount data"
input DiscountCreateInput {
    "List of binding this discount has on catalog, sections and/or products"
    bindings: [DiscountBindingInput!]!
    "ID of catalog  which discount belongs to"
    catalogId: UUID!
    "Short description"
    description: String
    "Type"
    discountType: DiscountType!
    "Quantity of items in cart needed for discount with `discountType == COUNTED` to be applied"
    freeQuantity: Int
    "Image"
    image: ImageInput
    "Should discount be applied automatically when an order where it's applicable is created"
    isAutomatic: Boolean!
    "Can discont be combined with other discounts"
    isCombined: Boolean!
    "Should percent be displayed alongside discount"
    isPercentShown: Boolean!
    "Should discount be visible to client"
    isShownToUser: Boolean!
    "Name"
    name: String!
    "Amount in percent"
    percent: BigDecimal!
    "Period when discount is active"
    period: ActivityPeriodInput!
    "ID of store which discount belongs to"
    storeId: UUID!
}

"Discount data"
input DiscountCreateInputV2 {
    basis: DiscountBasis!
    customerGroups: [UUID!]
    "Short description"
    description: String
    "Image"
    imageId: UUID
    "Is discount active"
    isActive: Boolean!
    "Should discount be applied automatically when an order where it's applicable is created"
    isAutomatic: Boolean!
    "Can discount be combined with other discounts"
    isCombined: Boolean!
    "Should percent be displayed alongside discount"
    isPercentShown: Boolean
    "Name"
    name: String!
    "Amount in percent"
    percent: BigDecimal!
    "Period when discount is active"
    period: ActivityPeriodInput!
    storeBindings: [LoyaltyStoreBindingInput!]!
}

"Discounts filtering object"
input DiscountFilterInput {
    "Catalog ID"
    catalogId: UUID
    "MENU ID FILTER NOT IMPLEMENTED YET! Menu ID, also filters applications by stockUnitId"
    menuId: UUID
    "Store ID"
    storeId: UUID
}

"Discounts filtering object"
input DiscountFilterInputV2 {
    "Filter by discount enabled state"
    active: Boolean
    "discountBasis e.g. discount for order or order_item"
    basis: DiscountBasis
    "Catalog ID"
    catalogId: UUID
    "discounts specific customer could get"
    customerId: UUID
    "MENU ID FILTER NOT IMPLEMENTED YET! Menu ID, also filters applications by stockUnitId"
    menuId: UUID
    "search string for discont name"
    search: String
    "Store ID"
    storeId: UUID
    "whether to filter out discounts which is used in any customer groups. This parameter has default value FALSE if does not passed"
    withoutCustomerGroups: Boolean
}

input DiscountProgramCreateInput {
    "Should discount be applied automatically when an order where it's applicable is created"
    automatic: Boolean!
    basis: DiscountBasis!
    "Can discount be combined with other discounts"
    combined: Boolean!
    dailyPeriods: [DailyPeriodInput!]
    percent: BigDecimal!
    promotionProgram: PromotionProgramCreateInput!
}

input DiscountProgramPatchUpdateRequest {
    "Should discount be applied automatically when an order where it's applicable is created"
    automatic: Boolean
    basis: DiscountBasis
    "Can discount be combined with other discounts"
    combined: Boolean
    dailyPeriods: [DailyPeriodInput!]
    id: UUID!
    percent: BigDecimal
    promotionProgram: PromotionProgramUpdateInput
}

input DiscountUpdateInput {
    "List of binding this discount has on catalog, sections and/or products"
    bindings: [DiscountBindingInput!]!
    "ID of catalog  which discount belongs to"
    catalogId: UUID!
    "Short description"
    description: String
    "Type"
    discountType: DiscountType!
    "Quantity of items in cart needed for discount with `discountType == COUNTED` to be applied"
    freeQuantity: Int
    "Discount ID"
    id: UUID!
    "Image"
    image: ImageInput
    "Is discount active"
    isActive: Boolean
    "Should discount be applied automatically when an order where it's applicable is created"
    isAutomatic: Boolean!
    "Can discont be combined with other discounts"
    isCombined: Boolean!
    "Should percent be displayed alongside discount"
    isPercentShown: Boolean!
    "Should discount be visible to client"
    isShownToUser: Boolean!
    "Name"
    name: String!
    "Amount in percent"
    percent: BigDecimal!
    "Period when discount is active"
    period: ActivityPeriodInput!
    "ID of store which discount belongs to"
    storeId: UUID!
}

input DiscountUpdateInputV2 {
    basis: DiscountBasis
    customerGroups: [UUID!]
    "Short description"
    description: String
    "Discount ID"
    id: UUID!
    "Image"
    imageId: UUID
    "Is discount active"
    isActive: Boolean
    "Should discount be applied automatically when an order where it's applicable is created"
    isAutomatic: Boolean
    "Can discount be combined with other discounts"
    isCombined: Boolean
    "Should percent be displayed alongside discount"
    isPercentShown: Boolean
    "Name"
    name: String
    "Amount in percent"
    percent: BigDecimal
    "Period when discount is active"
    period: ActivityPeriodInput
    storeBindings: [LoyaltyStoreBindingInput!]
}

input DocumentFilterInput {
    dateFrom: Instant
    dateTo: Instant
    search: String
    status: StatusDocument
    supplierId: UUID
    warehouseId: UUID
}

input DocumentFilterInputV2 {
    dateRange: DateRangeInput
    search: String
    statuses: [StatusDocument!]
    supplierIds: [UUID!]
    warehouseIds: [UUID!]
}

"Item described in non-inventory document"
input DocumentItemInput {
    "Amount of money transferred for this item"
    amount: Float
    "Comment"
    comment: String
    "If passed then factQuantity will be overridden due to convert policy"
    convertableUnit: ConvertableUnitInput
    "Currency of amount literal code (e.g. RUB)"
    currency: String
    "Factual quantity of items"
    factQuantity: Float
    "Name"
    name: String
    "Stock unit ID"
    stockUnit: StockUnitWarehouseInput!
}

input EmployeeFilterInput {
    active: Boolean
    hasAccount: Boolean
    name: String
    roleCode: RoleCode
}

input ExternalImageInput {
    ratio: Float!
    scale: Scale!
    url: String!
}

input FiscalDocumentInput {
    checksum: String
    client: ClientInput
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int!
    documentType: DocumentType
    electronically: Boolean
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String!
    items: [ReceiptItemWrapperInput]
    ofd: OfdInput
    ofdTicket: OfdTicketInput
    operator: OperatorInput
    orderId: UUID
    organizationName: String
    organizationVatin: String
    payments: [PaymentInput]
    registrationNumber: String
    roundTotal: Boolean
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
    taxSystem: TaxSystem
    type: FiscalReceiptType
}

input GetAnalyticsWarehouseItemMoveHistoriesDetailsSort {
    direction: SortDirection
    field: GetAnalyticsWarehouseItemMoveHistoriesDetailsSortField
}

input ImageInput {
    "data"
    body: FileUpload
    "image extension (e.g. jpg, png...)"
    extension: String
    externalImage: ExternalImageInput
    "image height"
    height: Int
    "image id"
    id: UUID
    "original image file name"
    originalFileName: String
    "image width"
    width: Int
}

input ImagesSizeInput {
    "image id"
    id: UUID!
    "array of image size inputs with width and height"
    sizes: [SizeInput!]!
}

"Filter for catalog elements"
input InCatalogFilterInput {
    "Catalog ID"
    catalogId: UUID!
    "Catalog element IDs"
    ids: [UUID!]
    "Maximum nesting depth"
    maxDepth: Long
    "Name substring"
    name: String
    "Parent sections"
    parentSectionIds: [UUID!]
    "Product type filter"
    productType: ProductType
    "Catalog element type"
    types: [CatalogEntityType!]
}

input IngredientInput {
    "Quantity in specified units"
    quantity: BigDecimal!
    "Stock Unit Id"
    stockUnitId: UUID!
    "Measurement unit type"
    unitType: UnitType!
}

"Inventory document data"
input InventoryDocumentCreateInput {
    "Date of inventory"
    date: Instant
    "Description"
    description: String
    "Inventory items"
    documentItems: [InventoryDocumentItemInput!]
    "ID of warehouse where inventory occured"
    fromWarehouseId: UUID!
    type: InventoryType
}

input InventoryDocumentFilterInputV2 {
    dateRange: DateRangeInput
    search: String
    statuses: [StatusDocument!]
    warehouseIds: [UUID!]
}

"Item described in inventory document"
input InventoryDocumentItemInput {
    "Amount of money transferred for this item"
    amount: Float
    "amount difference between fact and plan quantity"
    amountDelta: BigDecimal
    "total ARRIVAL and MOVE quantity of a corresponding document item since last inventory where warehouse TO is equal to warehouse where inventory is being processed"
    arrivalFromLastInventory: BigDecimal
    "Comment"
    comment: String
    "If passed then factQuantity will be overridden due to convert policy"
    convertableUnit: ConvertableUnitInput
    "Currency of amount literal code (e.g. RUB)"
    currency: String
    "Factual quanity of items"
    factQuantity: Float!
    "Last inventory Date"
    lastInventoryDate: Instant
    "Last inventory documentId"
    lastInventoryDocumentId: UUID
    "Leftover on last inventory (fact quantity from last inventory)"
    leftoverOnLastInventory: BigDecimal
    "Name"
    name: String
    "Initially planned quantity of items"
    planQuantity: Float!
    "quantity difference between fact and plan quantity"
    quantityDelta: BigDecimal
    "total sold quantity of a corresponding stock unit since last inventory"
    soldFromLastInventory: BigDecimal
    "Stock unit ID"
    stockUnit: StockUnitWarehouseInput!
    "total LEAVING and MOVE quantity of a corresponding document item since last inventory where warehouse FROM is equal to warehouse where inventory is being processed"
    writtenOffFromLastInventory: BigDecimal
}

"Inventory document data"
input InventoryDocumentUpdateInput {
    "Date of inventory"
    date: Instant
    "Description"
    description: String
    "Inventory items"
    documentItems: [InventoryDocumentItemInput!]
    "ID of warehouse where inventory occured"
    fromWarehouseId: UUID!
    "Inventory document ID"
    id: UUID!
    type: InventoryType
}

"Issuing support control claim input"
input IssueSupportControlClaimInput {
    organizationId: UUID!
}

input ItemBarcodeInput {
    alignment: Aligment
    fontDoubleHeight: Boolean
    fontDoubleWidth: Boolean
    fontNumber: Long
    linespacing: Long
    text: String
    wrap: TextWrap
}

input ItemCalculatePointsInput {
    id: UUID!
    price: BigDecimal!
}

input ItemTextInput {
    alignment: Aligment
    fontDoubleHeight: Boolean
    fontDoubleWidth: Boolean
    fontNumber: Long
    linespacing: Long
    text: String
    wrap: TextWrap
}

input KKTDocumentFilterInput {
    "An RFC-3339 compliant DateTime"
    dateTime: DateTimeRange
    documentNumber: [Int!]
    documentType: [DocumentType!]
    fiscalSign: [String!]
    "Fiscal storage serial number"
    fnSerial: [String!]
    registrationNumber: [String!]
    shiftNumber: [Int!]
}

input KKTDocumentsInput {
    correctionDocuments: [CorrectionDocumentInput]
    fiscalDocuments: [FiscalDocumentInput]
    reRegistrationDocuments: [ReRegistrationDocumentInput]
    registrationDocuments: [RegistrationDocumentInput]
    shiftClosingDocuments: [ShiftClosingDocumentInput]
    shiftOpeningDocuments: [ShiftOpeningDocumentInput]
}

"Data for kitchen workshop creation"
input KitchenWorkshopCreateInput {
    address: String
    autoConfirm: Boolean!
    "ID of warehouse which supplies items to kitchen workshop"
    inWarehouseId: UUID
    manualVerification: Boolean!
    "Name"
    name: String!
    "ID of warehouse which stores items made in kitchen workshop"
    outWarehouseId: UUID
    "ID of store kitchen workshop serves"
    storeId: UUID!
}

"Data for kitchen workshop update"
input KitchenWorkshopUpdateInput {
    address: String
    autoConfirm: Boolean!
    "Kitchen workshop ID"
    id: UUID!
    "ID of warehouse which supplies items to kitchen workshop"
    inWarehouseId: UUID
    manualVerification: Boolean!
    "Name"
    name: String!
    "ID of warehouse which stores items made in kitchen workshop"
    outWarehouseId: UUID
}

input LeavingByOrderDocumentV2FilterInput {
    documentId: UUID
    orderId: UUID
}

"Leaving document data"
input LeavingDocumentCreateInput {
    "Date of leaving"
    date: Instant
    "Descritpion"
    description: String
    "Left items"
    documentItems: [DocumentItemInput!]
    "ID of warehouse from which items left"
    fromWarehouseId: UUID!
}

"Leaving document data"
input LeavingDocumentUpdateInput {
    "Date of leaving"
    date: Instant
    "Descritpion"
    description: String
    "Left items"
    documentItems: [DocumentItemInput!]
    "ID of warehouse from which items left"
    fromWarehouseId: UUID!
    "Leaving document id"
    id: UUID!
}

"Light task data"
input LightTaskInput {
    "Light task ID"
    id: UUID
    "ID of warehouse which supplies items for this task"
    inWarehouseId: UUID!
    "ID of kitchen workshop this task has been assigned to"
    kitchenWorkshopId: UUID!
    "ID of order that spawned this task"
    orderId: UUID!
    "ID of warehouse which stores items made during this task"
    outWarehouseId: UUID!
    "ID of store this task is for"
    storeId: UUID!
    "Items created with this task"
    taskItems: [TaskItemInput!]
    taskNumber: Long
}

"Seccond-phase auth input."
input LoginInput {
    "Have to be passed if sign-in request does not allows password-auth"
    code: String
    "Have to be passed if sign-in request allows password-auth"
    password: String
    "Request ID received from first auth phase"
    requestId: UUID!
}

input LoyaltyBindingInput {
    entityId: UUID!
    entityType: BoundEntityType!
}

input LoyaltyPointsInput {
    "either points have been earn"
    earn: Int
    "either points have been spent"
    spent: Int
    "either amount have been spent"
    spentAmount: BigDecimal
}

input LoyaltyStoreBindingInput {
    bindings: [LoyaltyBindingInput!]!
    storeId: UUID!
}

input ManualLoyaltyPointsModificationInput {
    comment: String
    customerId: UUID!
    points: Int!
    type: LoyaltyPointsTransactionType!
}

input ManualModifyPointsInput {
    comment: String
    customerId: UUID!
    points: Int!
    type: PointTransactionType!
}

"Measuring something"
input MeasureDataInput {
    "Qty"
    quantity: BigDecimal!
    "Unit of measurement"
    unit: UnitType
}

"Menu input"
input MenuCreateInput {
    "menu name"
    name: String!
    "sort number"
    position: Int
    "store id that menu belongs to"
    storeId: UUID!
    "menu type"
    type: MenuType!
}

input MenuDuplicateInput {
    menuIdToDuplicate: UUID!
    storeIds: [UUID!]!
}

"Menu elements filter"
input MenuElementFilterInput {
    "Filter by active prop"
    active: Boolean
    "Depth level"
    depthLevel: [Int]
    "Filter by ids"
    ids: [UUID!]
    "Filter by menu ids"
    menuIds: [UUID!]
    "Name substring"
    name: String
    "Filter by section ids"
    sectionIds: [UUID!]
    "Filter by stockunit ids"
    stockUnitIds: [UUID!]
    types: [MenuElementType!]
}

input MenuFilterInput {
    search: String
}

"Menu item input"
input MenuItemInput {
    "is menu item active"
    active: Boolean
    "menu item id"
    id: UUID
    "Image id"
    imageIds: [UUID!]
    "menu id that current menu item belongs to"
    menuId: UUID!
    "menu item name"
    name: String!
    "sort number"
    position: Int
    "Sale price"
    salePrice: AmountDataInput
    "menu section id that current menu item belongs to"
    sectionId: UUID!
    "stock unit id that current menu item belongs to"
    stockUnitId: UUID!
}

input MenuItemPositionUpdateInput {
    afterId: UUID
    beforeId: UUID
    targetId: UUID!
}

"Menu section input"
input MenuSectionCreateInput {
    active: Boolean!
    "color code (e.g. `#FFAF8E`)"
    colorCode: String
    imageId: UUID
    "menu that menu section belongs to"
    menuId: UUID!
    "menu section name"
    name: String!
    "parent menu section id"
    parentSectionId: UUID
    "sort number"
    position: Int
}

input MenuSectionPatchUpdateInput {
    active: Boolean
    "colorSection enum"
    colorSection: ColorSection
    "menu section id"
    id: UUID!
    imageId: UUID
    "menu that menu section belongs to"
    menuId: UUID
    "menu section name"
    name: String
    "parent menu section id"
    parentSectionId: UUID
}

input MenuSectionPositionUpdateInput {
    afterId: UUID
    beforeId: UUID
    targetId: UUID!
}

input MenuSectionUpdateInput {
    active: Boolean!
    "color code (e.g. `#FFAF8E`)"
    colorCode: String
    "colorSection enum"
    colorSection: ColorSection
    "menu section id"
    id: UUID!
    imageId: UUID
    "menu that menu section belongs to"
    menuId: UUID!
    "menu section name"
    name: String!
    "parent menu section id"
    parentSectionId: UUID
    "sort number"
    position: Int
}

input MenuStructureInput {
    "allCatalog is true if you need to move the all catalog"
    allCatalog: Boolean!
    "selected/excluded category IDs from the catalog"
    categorySelection: MenuStructureSelectionInput!
    "selected/excluded SKU IDs from the catalog"
    itemSelection: MenuStructureSelectionInput!
    "useStruct is true if you need to move the catalog elements by structure, if false that move only skus without category structure"
    useStruct: Boolean!
}

input MenuStructureSelectionInput {
    "excluded list of IDs from the catalog"
    excluded: [UUID!]!
    "selected list of IDs from the catalog"
    selected: [UUID!]!
}

input MenuUpdateInput {
    "menu id"
    id: UUID!
    "menu name"
    name: String!
    "sort number"
    position: Int
    "store id that menu belongs to"
    storeId: UUID!
    "menu type"
    type: MenuType!
}

input ModifierGroupFilterInput {
    productIds: [UUID!]
    text: String
    type: ModifierType
}

input ModifierGroupInput {
    id: UUID!
    maxValue: Int!
    minValue: Int!
    name: String!
    required: Boolean!
    sort: Int!
    type: ModifierType!
}

input ModifierGroupSortInput {
    id: UUID!
    sort: Int!
}

input ModifierSortInput {
    id: UUID!
    sort: Int!
}

input ModifiersReportInput {
    dateRange: DateRangeInput!
    search: String
    sectionIds: [UUID!]
    stockUnitId: UUID!
    storeIds: [UUID!]
}

input MostPopularCategoriesWidgetInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input MostPopularProductsWidgetInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

"Move document data"
input MoveDocumentCreateInput {
    "Date of moving"
    date: Instant
    "Description"
    description: String
    "Moved items"
    documentItems: [DocumentItemInput!]
    "ID of source warehouse from which items were moved"
    fromWarehouseId: UUID!
    "ID of target warehouse to which items were moved"
    toWarehouseId: UUID!
}

"Move document data"
input MoveDocumentUpdateInput {
    "Date of moving"
    date: Instant
    "Description"
    description: String
    "Moved items"
    documentItems: [DocumentItemInput!]
    "ID of source warehouse from which items were moved"
    fromWarehouseId: UUID!
    "Move document ID"
    id: UUID!
    "ID of target warehouse to which items were moved"
    toWarehouseId: UUID!
}

input OfdInput {
    dns: String
    host: String
    name: String
    port: Int
    vatin: String
}

input OfdTicketInput {
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    fiscalSign: String
}

input OnlineMenuItemSetImageInput {
    "Image id"
    imageId: UUID
    "POS menu item id"
    menuItemId: UUID!
}

input OnlineMenuSectionSetImageInput {
    "Image id"
    imageId: UUID
    "POS menu section id"
    menuSectionId: UUID!
}

input OnlineMenuSetActiveStateInput {
    "Enabled / disabled"
    active: Boolean!
    "POS menu id"
    menuId: UUID!
}

input OperatorInput {
    name: String
    vatin: String
}

input OrderAddonInput {
    addonId: UUID!
    quantity: Int!
}

"Order"
input OrderCreateInput {
    "Comment"
    comment: String
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    dateLastPayedDate: Instant
    "Delivery data"
    deliveryInfo: DeliveryInfoInput
    "!!! @deprecated unused"
    discountAmount: AmountDataInput
    "Id of the employee who created / confirmed the order"
    employeeId: UUID
    fiscalStatus: FiscalStatus
    "Id of the guest who created the order"
    guestId: UUID
    "Id of the order"
    id: UUID
    "List of order items"
    items: [OrderItemInput!]!
    orderNumber: String
    "Shift id"
    shiftId: UUID
    shiftNumber: Int
    "Id store"
    storeId: UUID!
    "Terminal id"
    terminalId: UUID
    "!!! @deprecated unused"
    totalAmount: AmountDataInput
    "Order type"
    type: OrderType!
}

"Order filter"
input OrderFilterInput {
    """

    Start of a period (yyyy-MM-dd)
    !!! @deprecated use dateRange
    """
    dateFrom: LocalDate
    "lastModifiedDate range"
    dateRange: DateRangeInput
    """

    End of a period (yyyy-MM-dd)
    !!! @deprecated use dateRange
    """
    dateTo: LocalDate
    "Id of the employee who created / confirmed the order"
    employeeId: UUID
    "Id of the order"
    orderId: UUID
    "Id of the shift in which the order was created"
    shiftId: UUID
    "Order status"
    status: OrderStatus
    "Id of the store on which the order was created"
    storeId: UUID
    "Id of the terminal, on which the order was created"
    terminalId: UUID
}

"Order action history entry"
input OrderHistoryEntryInput {
    "Action description. Not blank"
    action: String!
    "Action caused by terminal with ID"
    terminalId: UUID!
    "Action timestamp"
    timestamp: Instant!
}

"Item by order"
input OrderItemInput {
    amount: AmountDataInput!
    "IDs of discounts applied to the order"
    appliedDiscountIds: [UUID!]
    """

    Discounts applied to the order
    !!! @deprecated use appliedDiscountIds
    """
    appliedDiscounts: [AppliedDiscountInput!]!
    appliedModifiers: [AppliedModifierInput!]
    barcode: String
    "Additional comment"
    comment: String
    "Course of serving the position to the guest"
    course: Int
    discountAmount: AmountDataInput!
    "The number of the guest to whom the product (s) will be served by position"
    guest: Int
    """

    The numbers of the guests to whom the product (s) will be served by position
    !!! @deprecated use guest
    """
    guestsNumbers: [Int!]
    "Id of position"
    id: UUID
    primePrice: AmountDataInput
    "Number of products. The unit is taken from the stock unit"
    quantity: MeasureDataInput!
    salePrice: AmountDataInput!
    "Status of product (s) by item"
    status: OrderItemStatus
    "Id stock unit"
    stockUnitId: UUID!
}

input OrderItemPackCreateInput {
    amount: AmountDataInput!
    """

    IDs of discounts applied to the order
    @deprecated (reason: "use appliedDiscounts")
    """
    appliedDiscountIds: [UUID!]
    "Discounts applied to the order"
    appliedDiscounts: [AppliedDiscountInput!]
    barcode: String
    "Additional comment"
    comment: String
    "Course of serving the position to the guest"
    course: Int
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    discountAmount: AmountDataInput!
    "The number of the guest to whom the product (s) will be served by position"
    guest: Int
    """

    The numbers of the guests to whom the product (s) will be served by position
    !!! @deprecated use guest
    """
    guestsNumbers: [Int!]
    "Id of position"
    id: UUID!
    modifiers: [AppliedModifierInput!]
    name: String!
    positionTypeCode: PositionTypeCode
    primePrice: AmountDataInput
    "Number of products. The unit is taken from the stock unit"
    quantity: MeasureDataInput!
    salePrice: AmountDataInput!
    "Taxation system"
    sno: Sno
    "Status of product (s) by item"
    status: OrderItemStatus!
    "Id stock unit"
    stockUnitId: UUID!
    vatType: VatType
    "Is it possible to weigh the product"
    weighable: Boolean
}

input OrderItemsToKitchenInput {
    kitchenWorkShopId: UUID!
    techCardsId: [UUID!]!
}

input OrderLabelInput {
    key: String!
    value: String!
}

"Order"
input OrderPackCreateInput {
    "Sign of a closed order"
    canceled: Boolean!
    "Comment"
    comment: String
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    dateLastPayedDate: Instant
    "Delivery data"
    deliveryInfo: DeliveryInfoInput
    "!!! @deprecated unused"
    discountAmount: AmountDataInput
    "Id of the employee who created / confirmed the order"
    employeeId: UUID
    fiscalStatus: FiscalStatus
    "Id of the guest who created the order"
    guestId: UUID
    "Id of the order"
    id: UUID!
    "List of order items"
    items: [OrderItemPackCreateInput!]!
    labels: [OrderLabelInput!]!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    lastModifiedDate: Instant
    orderNumber: String!
    "Sign of a paid order"
    payed: Boolean!
    "Shift id"
    shiftId: UUID
    shiftNumber: Int
    status: OrderStatus!
    "Id store"
    storeId: UUID!
    "Terminal id"
    terminalId: UUID!
    "!!! @deprecated unused"
    totalAmount: AmountDataInput
    "Order type"
    type: OrderType!
}

input OrderPackInput {
    order: OrderPackCreateInput!
    orderPayments: [OrderPackPaymentInput!]
}

"Payment by order"
input OrderPackPaymentInput {
    "Amount of payment"
    amount: PaymentAmountDataInput!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    createdDate: Instant!
    id: UUID!
    "Pay system icon"
    paySystemIcon: PaySystemIcon
    "Id of the payment system used to create the payment"
    paySystemId: UUID!
    "Pay system name"
    paySystemName: String
    "Pay system type"
    paySystemType: PaySystemType
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    payedDate: Instant
    status: PaymentStatus!
}

"Payment by order"
input OrderPaymentInput {
    "Amount of payment"
    amount: PaymentAmountDataInput!
    id: UUID
    "ID of order, if it already exists"
    orderId: UUID
    "Id of the payment system used to create the payment"
    paySystemId: UUID!
    "Format yyyy-MM-dd'T'HH:mm:ss.SS'Z'"
    payedDate: Instant
    status: PaymentStatus
}

input OrderPaymentPaySystemInput {
    "Icon, if present"
    icon: PaySystemIcon
    id: UUID!
    "Name"
    name: String!
    "Type"
    type: PaySystemType!
}

input OrderTypeWidgetInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input OrderWidgetInput {
    customerId: UUID
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input OrdersReportInput {
    dateRange: DateRangeInput!
    paySystemIds: [UUID!]
    search: String
    shiftIds: [UUID!]
    shiftNumbers: [Int!]
    statuses: [OrderState]
    storeIds: [UUID!]
}

input OrdersReportSort {
    direction: SortDirection
    field: OrdersReportSortField
}

input OrganizationFilterInput {
    search: String
}

"Page request"
input PageRequestInput {
    "Page number"
    page: Int!
    "Page size"
    size: Int!
    "Sort order"
    sort: [SortOrderInput!]
}

"Page request without sort"
input PageableInput {
    page: Int!
    size: Int!
}

"Payment system"
input PaySystemCreateInput {
    active: Boolean!
    "Pay system icon type"
    icon: PaySystemIcon
    "Deprecated, use icon"
    iconId: UUID
    "Payment system name"
    name: String!
    "Sequential number of the payment system in the list of payment systems"
    position: Int
    "Payment system type"
    type: PaySystemType!
}

input PaySystemInput {
    "Is payment system active"
    active: Boolean!
    "Pay system icon type"
    icon: PaySystemIcon
    "Deprecated, use icon"
    iconId: UUID
    "Payment system ID, if already assigned"
    id: UUID
    "Payment system name"
    name: String!
    "Payment system type"
    type: PaySystemType!
}

input PaySystemReportInput {
    dateRange: DateRangeInput!
    paySystemIds: [UUID!]
    storeIds: [UUID!]
}

input PaySystemReportSort {
    direction: SortDirection
    field: PaySystemReportSortField
}

input PaySystemUpdateInput {
    "Sign of disconnection of the payment system"
    active: Boolean!
    "Pay system icon type"
    icon: PaySystemIcon
    "Deprecated, use icon"
    iconId: UUID
    "Payment system id"
    id: UUID!
    "Payment system name"
    name: String
    "Sequential number of the payment system in the list of payment systems"
    position: Int
    "Payment system type"
    type: PaySystemType!
}

input PaymentAmountDataInput {
    "Value of money"
    amountValue: BigDecimal!
    "Money currency"
    currencyUnit: String!
}

input PaymentInput {
    sum: BigDecimal
    type: PaymentType
}

"Payment system"
input PaymentSystemCreateInput {
    "Pay system icon type"
    icon: PaySystemIcon!
    "Payment system name"
    name: String!
    "stores to activate"
    storeIds: [UUID!]
    "Payment system type"
    type: PaySystemType!
}

input PaymentSystemUpdateInput {
    active: Boolean
    addStoreIds: [UUID!]
    icon: PaySystemIcon
    id: UUID!
    name: String
    removeStoreIds: [UUID!]
    type: PaySystemType
}

input PaymentSystemWidgetInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input PaymentSystemsFilterInput {
    hasStores: Boolean
    search: String
    storeIds: [UUID!]
}

input PaymoPaymentFilterInput {
    "Payment amount"
    amount: BigDecimal
    "PaymentDate range"
    dateRange: DateRangeInput
    "Payment desctiption"
    description: String
    "Payment Number"
    paymentNumber: String
    "Payment status"
    status: PaymentStatus
    "Store id"
    storeId: UUID!
}

input PointPriceInput {
    monetary: Int!
    points: Int!
}

input PointTransactionFilterInput {
    beginsAt: LocalDate
    customerIds: [UUID!]
    endsAt: LocalDate
    orderIds: [UUID!]
    storeIds: [UUID!]
}

input PositionInput {
    alignment: Aligment
    barcode: String
    barcodeType: BarcodeType
    scale: Int
}

"Cooking process data for standalone saving"
input ProcessCreateInput {
    "Name"
    name: String
    "ID of organization which created this process"
    organizationId: UUID
}

input ProcessUpdateInput {
    "Process ID"
    id: UUID
    "Name"
    name: String
    "ID of organization which created this process"
    organizationId: UUID
}

"Product input data"
input ProductCreateInput {
    "ID of catalog which the product belongs to"
    catalogId: UUID!
    "Product name"
    name: String!
    "Position type for product"
    positionTypeCode: PositionTypeCode
    "ID of section which the product belongs to"
    sectionId: UUID
    "is semi-product"
    semiproduct: Boolean
    "list of product stockUnits"
    stockUnits: [StockUnitInput!]!
    "TaxProfile for product"
    taxProfile: TaxProfileCreateInput
    "Type of product"
    type: ProductType
}

"Filter object for catalog sections"
input ProductFilterInput {
    "Catalog ID"
    catalogId: UUID!
    "return products with or without sections. if null return products with and without sections"
    isSection: Boolean
    "Filter by modifier group ids"
    modifierGroupIdsWhereUsedAsModifier: [UUID!]
    "Search substring within section name"
    search: String
    "Section ID"
    sectionId: UUID
    "Section ID List"
    sectionIds: [UUID!]
    "Filter by SKU ids"
    stockUnitIds: [UUID!]
    "Type filter"
    type: ProductType
}

input ProductPatchUpdateInput {
    "Product id"
    id: UUID!
    "Product name"
    name: String
    "ID of section which the product belongs to"
    sectionId: UUID
    "list of product stockUnits"
    stockUnit: StockUnitPatchUpdateInput
    "StockUnit techCard"
    techCard: TechCardPatchUpdateInput
    "Type of product"
    type: ProductType
}

input ProductReportSort {
    direction: SortDirection
    field: ProductReportSortField
}

input ProductUpdateInput {
    "ID of catalog which the product belongs to"
    catalogId: UUID!
    "Product id"
    id: UUID!
    "Product name"
    name: String!
    "Position type for product"
    positionTypeCode: PositionTypeCode
    "ID of section which the product belongs to"
    sectionId: UUID
    "is semi-product"
    semiproduct: Boolean
    "list of product stockUnits"
    stockUnits: [StockUnitInput!]!
    "TaxProfile for product"
    taxProfile: TaxProfileCreateInput
    "Type of product"
    type: ProductType
}

"new filter object for products"
input ProductsFilterInput {
    catalogId: UUID
    excludeIds: [UUID!]
    excludeStockUnitIds: [UUID!]
    parentSectionIds: [UUID!]
    search: String
    type: ProductType
    types: [ProductType!]
}

input ProductsReportInput {
    dateRange: DateRangeInput!
    productTypes: [ProductType!]
    search: String
    sectionIds: [UUID!]
    storeIds: [UUID!]
}

input ProductsReportLinkedProductsInput {
    dateRange: DateRangeInput!
    search: String
    sectionIds: [UUID!]
    stockUnitId: UUID!
    storeIds: [UUID!]
}

input ProductsReportProductModifiersInput {
    dateRange: DateRangeInput!
    search: String
    sectionIds: [UUID!]
    stockUnitId: UUID!
    storeIds: [UUID!]
}

input PromotionProgramCreateInput {
    active: Boolean!
    beginsAt: LocalDate
    categoryIds: SelectionInput!
    customerGroupIds: SelectionInput!
    description: String
    endsAt: LocalDate
    imageId: UUID
    name: String!
    stockUnitIds: SelectionInput!
    storeIds: SelectionInput!
}

input PromotionProgramFilterInput {
    active: Boolean
    groupIds: [UUID!]
    ids: [UUID!]
    name: String
    promotionType: PromotionType
    storeIds: [UUID!]
}

input PromotionProgramSort {
    direction: MarketingSortDirection
    fieldName: PromotionProgramSortField
}

input PromotionProgramUpdateInput {
    active: Boolean
    beginsAt: LocalDate
    categoryIds: SelectionInput
    customerGroupIds: SelectionInput
    description: String
    endsAt: LocalDate
    imageId: UUID
    name: String
    stockUnitIds: SelectionInput
    storeIds: SelectionInput
}

input ReRegistrationDocumentInput {
    agentSigns: [AgentSign]
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int!
    documentType: DocumentType
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String!
    fnsUrl: String
    kktRegistrationNumber: String
    machineSerial: String
    modeSigns: [RegistrationModeSign]
    ofd: OfdInput
    ofdTicket: OfdTicketInput
    operator: OperatorInput
    organizationEmail: String
    organizationName: String
    organizationVatin: String
    reason: [ReRegistrationReason]
    registrationNumber: String
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
    taxSystems: [TaxSystem]
}

input ReceiptItemWrapperInput {
    barcode: ItemBarcodeInput
    position: PositionInput
    text: ItemTextInput
}

input ReceiptWishInput {
    text: String!
}

input RegistrationDocumentInput {
    agentSigns: [AgentSign]
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int!
    documentType: DocumentType
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String!
    fnsUrl: String
    kktRegistrationNumber: String
    machineSerial: String
    modeSigns: [RegistrationModeSign]
    ofd: OfdInput
    ofdTicket: OfdTicketInput
    operator: OperatorInput
    organizationEmail: String
    organizationName: String
    organizationVatin: String
    registrationNumber: String
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
    taxSystems: [TaxSystem]
}

"Return document data"
input ReturnDocumentCreateInput {
    "Date of return"
    date: Instant
    "Description"
    description: String
    "Returned items"
    documentItems: [DocumentItemInput!]
    "ID of warehouse from which items were returned"
    fromWarehouseId: UUID!
    "ID of supplier to which items were returned"
    supplierId: UUID!
}

"Return document data"
input ReturnDocumentUpdateInput {
    "Date of return"
    date: Instant
    "Description"
    description: String
    "Returned items"
    documentItems: [DocumentItemInput!]
    "ID of warehouse from which items were returned"
    fromWarehouseId: UUID!
    "Return document ID"
    id: UUID!
    "ID of supplier to which items were returned"
    supplierId: UUID!
}

input SalesByHourWidgetInput {
    "data range from to filter(yyyy-MM-dd)"
    dateRange: DateRangeInput!
    "list of stores to filter"
    storeIds: [UUID!]
}

input SalesByWeekDayWidgetInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input SalesTodayWidgetInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input SaveStoreReceiptSettingsInput {
    settings: StoreReceiptSettingsInput!
    storeId: UUID!
}

"Schedule"
input ScheduleInput {
    "Days of the week"
    daysOfWeek: [DayOfWeek!]
    "Start time 'HH: mm'"
    fromTime: String!
    "Schedule type"
    scheduleType: ScheduleType!
    "End time 'HH: mm'"
    toTime: String!
}

"new filter object for catalog sections"
input SectionsFilterInput {
    catalogId: UUID
    depthLevel: Int
    parentSectionIds: [UUID!]
    search: String
}

input SelectionInput {
    all: Boolean!
    excluded: [UUID!]
    selected: [UUID!]
}

input ShiftClosingDocumentInput {
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int!
    documentType: DocumentType
    documentsCount: Int
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String!
    ofd: OfdInput
    ofdTicket: OfdTicketInput
    operator: OperatorInput
    organizationName: String
    organizationVatin: String
    registrationNumber: String
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
}

input ShiftOpeningDocumentInput {
    "An RFC-3339 compliant DateTime"
    dateTime: DateTime
    documentNumber: Int!
    documentType: DocumentType
    ffdVersion: FFDVersion
    fiscalSign: String
    "Fiscal storage serial number"
    fnSerial: String!
    ofd: OfdInput
    ofdTicket: OfdTicketInput
    operator: OperatorInput
    organizationName: String
    organizationVatin: String
    registrationNumber: String
    shiftNumber: Int
    storeAddress: String
    storePlaceName: String
}

input SizeInput {
    "image height"
    height: Int!
    "size type (e.g. `original`, `large` or 'medium`)"
    sizeType: String!
    "image width"
    width: Int!
}

input SnapshotOrderEmployeeInput {
    firstName: String!
    id: UUID!
    lastName: String!
}

"Sort order"
input SortOrderInput {
    "Sorting direction"
    direction: SortDirection
    "Field name to sort by"
    fieldName: String!
}

input SpendOrderPointsInput {
    customerId: UUID!
    orderId: UUID!
    spendPoints: Int!
    storeId: UUID!
    terminalId: UUID!
}

input StockUnitFilterInput {
    ids: [UUID!]
}

"StockUnit input data"
input StockUnitInput {
    barcodes: [BarcodeInput!]
    "StockUnit ID (only when update)"
    id: UUID
    imageIds: [UUID!]
    "StockUnit list of images"
    images: [ImageInput!]
    "StockUnit name"
    name: String!
    "StockUnit prime price"
    primePrice: AmountDataInput
    "quantity by subUnit"
    quantity: BigDecimal
    "StockUnit sale price"
    salePrice: AmountDataInput!
    "unit type kg, g, l,ml"
    subUnit: UnitType
    "StockUnit techCard"
    techCard: CatalogTechCardInput
    "StockUnit unit type"
    unit: UnitType!
    "weighable"
    weighable: Boolean!
}

input StockUnitModifierInput {
    name: String!
    pinned: Boolean!
    sort: Int!
    stockUnitId: UUID!
}

input StockUnitModifierUpdateInput {
    id: UUID!
    name: String!
    pinned: Boolean!
    sort: Int!
    stockUnitId: UUID!
}

input StockUnitPatchUpdateInput {
    addBarcodes: [String!]
    addImageIds: [UUID!]
    "StockUnit name"
    name: String
    "Position type for product"
    positionTypeCode: PositionTypeCode
    "StockUnit prime price"
    primePrice: AmountDataInput
    "quantity by subUnit"
    quantity: BigDecimal
    removeBarcodeIds: [String!]
    removeImageIds: [UUID!]
    "StockUnit sale price"
    salePrice: AmountDataInput
    "TaxProfile for product"
    taxProfile: TaxProfilePatchUpdateInput
    "StockUnit unit type"
    unit: UnitType
    "weighable"
    weighable: Boolean
}

input StockUnitWarehouseInput {
    "StockUnit ID"
    id: UUID
    "StockUnit name"
    name: String!
    "StockUnit primePrice"
    primePrice: AmountDataInput!
    "quantity by subUnit"
    quantity: BigDecimal
    "unit type kg, g, l,ml"
    subUnit: UnitType
    "StockUnit unit type"
    unit: UnitType!
    "weighable"
    weighable: Boolean
}

"Store"
input StoreCreateInput {
    "Store address"
    address: String
    "Checking account"
    bankAccount: String
    bankName: String
    bic: String
    "Store directory id"
    catalogId: UUID!
    ceo: String
    correspondentAccount: String
    "Currency in which settlements are made in the store"
    currency: String!
    "Cost of delivery"
    deliveryAmount: AmountDataInput
    "Maximum delivery time 'HH: mm'"
    deliveryTimeMax: String
    "Minimum delivery time 'HH: mm'"
    deliveryTimeMin: String
    "Store geo location"
    geoLocation: CoordinatesInput
    "Checkpoint"
    kpp: String
    "Legal address"
    legalAddress: String
    "Name of shop"
    name: String!
    "OGRN"
    ogrn: String
    okpo: String
    "Organization ID"
    organizationId: UUID!
    "Name of the organization"
    organizationName: String
    phone: String
    "Sequential number in the list of stores of the organization"
    position: Int
    "Post address"
    postAddress: String
    "The postal address corresponds to the legal"
    postAddressCoincidence: Boolean
    "Index"
    postalCode: String
    registrationDate: Instant
    respectWorkingHoursForBooking: Boolean
    "List of store schedules"
    schedules: [ScheduleInput!]
    "Id store delivery warehouse"
    shippingWarehouseId: UUID
    signer: String
    signerBase: SignerBase
    tablesBookingFeatureEnabled: Boolean
    tablesFeatureEnabled: Boolean
    "Store type"
    type: StoreType!
    "INN"
    vatin: String
    workingScheduleEnabled: Boolean
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String
}

"Store filter"
input StoreFilterInput {
    "Sign of disconnection of the store"
    active: Boolean
    "Store address"
    address: String
    "Directory id"
    catalogId: UUID
    "Currency in which settlements are made in the store"
    currency: String
    """

    List of device id of the store
    !!! @deprecated unused
    """
    deviceServerIdList: [UUID!]
    "Id store"
    id: UUID
    "Store name"
    name: String
    "Id store delivery warehouse"
    shippingWarehouseId: UUID
    "List of id terminals of the store"
    terminalIdList: [UUID!]
    "Store type"
    type: StoreType
}

input StoreFilterInputV2 {
    name: String
}

input StoreGhostUpdateInput {
    "Sign of disconnection of the ghost store"
    active: Boolean
    "Ghost store actual address"
    actualAddress: String
    """

    Ghost store address
    !!! @deprecated use actualAddress
    """
    address: String
    "Id of the ghost store directory"
    catalogId: UUID!
    "Array of coordinates with latitude and longitude"
    coordinates: [CoordinatesInput!]
    "Cost of delivery"
    deliveryAmount: AmountDataInput
    "Maximum delivery time 'HH: mm'"
    deliveryTimeMax: String
    "Minimum delivery time 'HH: mm'"
    deliveryTimeMin: String
    "Id store-ghost"
    id: UUID!
    "Name of the ghost store"
    name: String!
    "Id of the parent store"
    parentStoreId: UUID!
    "Sequential number in the list of the parent store"
    position: Int
    "List of ghost store schedules"
    schedules: [ScheduleInput!]
    "Id store supply store ghost"
    shippingWarehouseId: UUID
    "The name of the Time Zone in which the ghost store operates (IANA Time Zone Database)"
    zoneId: String!
}

input StoreInfoUpdateInput {
    "Store address"
    address: String
    "Store catalog ID"
    catalogId: UUID!
    "Array of coordinates with latitude and longitude"
    coordinates: [CoordinatesInput!]
    "Currency in which settlements are made in the store"
    currency: String!
    "Cost of delivery"
    deliveryAmount: AmountDataInput
    "Maximum delivery time 'HH: mm'"
    deliveryTimeMax: String
    "Minimum delivery time 'HH: mm'"
    deliveryTimeMin: String
    "Store geo location"
    geoLocation: CoordinatesInput
    "Id store"
    id: UUID!
    "Name of shop"
    name: String!
    """

    Pay system IDs
    !!! @deprecated use storePaySystems
    """
    paySystems: [UUID!]
    "Sequential number in the list of stores of the organization"
    position: Int
    "List of store schedules"
    schedules: [ScheduleInput!]
    "Id store delivery warehouse"
    shippingWarehouseId: UUID
    "Pay systems"
    storePaySystems: [PaySystemInput!]
    """

    TaxProfile for store
    !!! @deprecated unused
    """
    taxProfile: TaxProfileCreateInput
    "Store type"
    type: StoreType!
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String!
}

input StoreInfoUpdateInputV3 {
    "existing paySystemIds to add"
    addPaySystemIds: [UUID!]
    "existing schedulesIds to add"
    addScheduleIds: [UUID!]
    "Store address"
    address: String
    "Store catalog ID"
    catalogId: UUID
    "Currency in which settlements are made in the store"
    currency: String
    "Cost of delivery"
    deliveryAmount: AmountDataInput
    "Maximum delivery time 'HH: mm'"
    deliveryTimeMax: String
    "Minimum delivery time 'HH: mm'"
    deliveryTimeMin: String
    "Store geo location"
    geoLocation: CoordinatesInput
    "Id store"
    id: UUID!
    "Name of shop"
    name: String
    "Sequential number in the list of stores of the organization"
    position: Int
    postAddress: String
    "existing paySystemIds to remove"
    removePaySystemIds: [UUID!]
    "existing schedulesIds to remove"
    removeScheduleIds: [UUID!]
    "Id store delivery warehouse"
    shippingWarehouseId: UUID
    "Store type"
    type: StoreType
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String
}

input StoreReceiptSettingsInput {
    "Free comment to be printed"
    freeComment: String
    "Flag to enable printing of a custom comment on the receipt"
    printFreeComment: Boolean!
    "Flag to enable printing of an order comment on the receipt"
    printOrderComment: Boolean!
    "Flag to enable printing of a store logo on the receipt"
    printStoreLogo: Boolean!
    "Flag to enable printing of a store name on the receipt"
    printStoreName: Boolean!
    "Flag to enable printing of a wishes on the receipt"
    printWishes: Boolean!
    "Store logo image id"
    storeLogoImageId: UUID
    "Store name to be printed"
    storeName: String
    "Wishes"
    wishes: [ReceiptWishInput!]
}

input StoreRequisitesUpdateInput {
    "Checking account"
    bankAccount: String
    bankName: String
    bic: String
    "CEO name"
    ceo: String
    correspondentAccount: String
    "Id store"
    id: UUID!
    "Checkpoint"
    kpp: String
    "Legal address"
    legalAddress: String
    "OGRN"
    ogrn: String
    okpo: String
    "Name of the organization"
    organizationName: String
    phone: String
    "Position type for store"
    positionTypeCode: PositionTypeCode
    "Post address"
    postAddress: String
    "The postal address corresponds to the legal"
    postAddressCoincidence: Boolean
    "Index"
    postalCode: String
    registrationDate: Instant
    signer: String
    signerBase: SignerBase
    "INN"
    vatin: String
}

input StoreTableGroupsInput {
    storeId: UUID!
    tableGroups: [TableGroupInput!]
}

input StoreUpdateInput {
    addScheduleIds: [UUID!]
    address: String
    bankAccount: String
    bankName: String
    bic: String
    catalogId: UUID
    ceo: String
    correspondentAccount: String
    currency: String
    deliveryAmount: AmountDataInput
    deliveryTimeMax: String
    deliveryTimeMin: String
    geoLocation: CoordinatesInput
    id: UUID!
    "Checkpoint"
    kpp: String
    legalAddress: String
    name: String
    ogrn: String
    okpo: String
    organizationName: String
    phone: String
    position: Int
    positionTypeCode: PositionTypeCode
    postAddress: String
    "The postal address corresponds to the legal"
    postAddressCoincidence: Boolean
    postalCode: String
    registrationDate: Instant
    removeScheduleIds: [UUID!]
    respectWorkingHoursForBooking: Boolean
    schedules: [ScheduleInput!]
    shippingWarehouseId: UUID
    signer: String
    signerBase: SignerBase
    tablesBookingFeatureEnabled: Boolean
    tablesFeatureEnabled: Boolean
    type: StoreType
    vatin: String
    workingScheduleEnabled: Boolean
    "Currency in which settlements are made in the store"
    zoneId: String
}

"Supplier data"
input SupplierCreateInput {
    "Address"
    address: String
    "Company name"
    companyName: String
    "Name of contact in supplier"
    contactPoint: String
    "Short description"
    description: String
    "E-mail"
    email: String
    "INN"
    inn: String
    "KPP"
    kpp: String
    "Phone (should match one of patterns: +7-XXX-XXX-XX-XX, 7-XXX-XXX-XX-XX, 8-XXX-XXX-XX-XX, where hyphens are optional)"
    phone: String
    "Legal type of supplier"
    type: TypeSupplier!
}

input SupplierFilterInput {
    search: String
}

input SupplierUpdateInput {
    "Address"
    address: String
    "Company name"
    companyName: String
    "Name of contact in supplier"
    contactPoint: String
    "Short description"
    description: String
    "E-mail"
    email: String
    "Supplier ID"
    id: UUID!
    "INN"
    inn: String
    "KPP"
    kpp: String
    "Phone (should match one of patterns: +7-XXX-XXX-XX-XX, 7-XXX-XXX-XX-XX, 8-XXX-XXX-XX-XX, where hyphens are optional)"
    phone: String
    "Legal type of supplier"
    type: TypeSupplier!
}

input SupplierUpdateInputV2 {
    "Address"
    address: String
    "Company name"
    companyName: String
    "Name of contact in supplier"
    contactPoint: String
    "Short description"
    description: String
    "E-mail"
    email: String
    "Supplier ID"
    id: UUID!
    "INN"
    inn: String
    "KPP"
    kpp: String
    "Phone (should match one of patterns: +7-XXX-XXX-XX-XX, 7-XXX-XXX-XX-XX, 8-XXX-XXX-XX-XX, where hyphens are optional)"
    phone: String
    "Legal type of supplier"
    type: TypeSupplier!
}

input TableBookingFilterInput {
    status: [TableBookingStatus!]
}

input TableBookingInput {
    clientId: UUID
    comment: String
    dateEnd: LocalDate!
    "Local date string , with no associated timezone, such as YYYY-MM-DD"
    dateStart: LocalDate!
    guestCount: Int!
    status: TableBookingStatus!
    tableId: UUID!
    timeEnd: LocalTime!
    "Time in the ISO-8601 calendar system, such as 10:15:30"
    timeStart: LocalTime!
}

input TableGroupInput {
    archived: Boolean!
    id: UUID!
    name: String!
    tables: [TableInput!]
}

input TableInput {
    id: UUID!
    name: String!
    position: Int!
    seatsCount: Int!
}

input TablesReportFilterInput {
    dateRange: DateRangeInput!
    storeIds: [UUID!]
}

input TablesReportInput {
    filter: TablesReportFilterInput
}

"Task item data"
input TaskItemInput {
    "Ingredient"
    ingredients: [IngredientInput]
    "Quantity in specified units"
    quantity: BigDecimal!
    "Tech card ID"
    techCardId: UUID!
    "Measurement unit type"
    unitType: UnitType!
}

"Tax profile"
input TaxProfileCreateInput {
    "Taxation system"
    sno: Sno
    "VAT type"
    vat: VatType
}

input TaxProfilePatchUpdateInput {
    "Taxation system"
    sno: Sno!
    "VAT type"
    vat: VatType!
}

"Tax profile"
input TaxProfileUpdateInput {
    "Id tax profile"
    id: UUID!
    "Taxation system"
    sno: Sno!
    "VAT type"
    vat: VatType!
}

input TechCardItemAddInput {
    "Brutto quantity of item in specified units"
    brutto: BigDecimal!
    "Measurement unit type"
    bruttoUnitType: UnitType!
    "Netto quantity of item in specified units"
    netto: BigDecimal!
    "ID of contained stockUnit"
    stockUnitId: UUID!
}

input TechCardPatchUpdateInput {
    addItems: [TechCardItemAddInput!]
    "description of the cooking process"
    processOfCooking: String
    removeItemIds: [UUID!]
}

"New terminal store"
input TerminalCreateInput {
    "Terminal menu id"
    menuId: UUID!
    "Terminal name"
    name: String!
    "Sequential number of the terminal in the list of terminals"
    position: Int
    "Store ID"
    storeId: UUID!
}

"Terminal save/update input"
input TerminalInput {
    "Terminal hardware or software fingerprint"
    fingerprint: String!
    "Terminal id, will be generated automatically if not specified"
    id: UUID
    "Terminal menu id"
    menuId: UUID!
    "Terminal name"
    name: String!
    "Last order sequence number"
    orderSequence: Long
    "Store ID"
    storeId: UUID!
}

"Terminal save/update input"
input TerminalInputData {
    "Terminal hardware or software fingerprint"
    fingerprint: String!
    "Terminal menu id"
    menuId: UUID!
    "Terminal name"
    name: String!
    "Last order sequence number"
    orderSequence: Long!
    "Store ID"
    storeId: UUID!
}

"Existing terminal store"
input TerminalUpdateInput {
    "Terminal disconnection sign"
    active: Boolean
    "Terminal id"
    id: UUID!
    "Terminal menu id"
    menuId: UUID!
    "Terminal name"
    name: String!
    "Sequential number of the terminal in the list of terminals"
    position: Int
}

input TextModifierInput {
    name: String!
    pinned: Boolean!
    sort: Int!
}

input TextModifierUpdateInput {
    id: UUID!
    name: String!
    pinned: Boolean!
    sort: Int!
}

input TimeSeriesInput {
    grouping: DateGrouping!
}

"Employee updating input"
input UpdateEmployeeInput {
    "Describes employee accessibility"
    active: Boolean!
    "Living address"
    address: String
    "Date of birth (ISO-8601)"
    dateOfBirth: Instant
    "Date of employment (ISO-8601)"
    dateOfEmployment: Instant
    "Employee alias name"
    firstName: String!
    "ID of updating employee"
    id: UUID!
    lastName: String!
    "Medical book expire date (ISO-8601)"
    medicalBookExpiresAt: Instant
    middleName: String
    "Employee access pin-code"
    pin: String
    "СНИЛС"
    snils: String
    "Usergroup membership"
    userGroups: [UserGroupInput!]!
    "ИНН"
    vatin: String
    "Contact email"
    workEmail: String!
    "Contact phone"
    workPhone: String
}

"Employee invitation update input. Confiramtion token will be automatically refreshed"
input UpdateEmployeeInvitationInput {
    "Invitation expire date (ISO-8601)"
    expiresAt: Instant
    "Invitation ID"
    invitationId: UUID!
}

input UpdateModifierGroupInput {
    "there is no concept of activity at the moment"
    active: Boolean
    id: UUID!
    maxValue: Int
    minValue: Int
    name: String
    required: Boolean
    sort: Int
    type: ModifierType
}

"Organization updating input"
input UpdateOrganizationInput {
    "Currency unit e.g. RUB"
    currencyUnit: String
    "Updating organization ID"
    id: UUID
    "Organization name"
    name: String
}

"Organization invitation updating input"
input UpdateOrganizationInvitationInput {
    "Describes active state for this invitation"
    active: Boolean
    id: UUID
    "Name of invitation"
    name: String!
}

input UpdateTableBookingInput {
    id: UUID!
    tableBooking: TableBookingInput!
}

input UploadAppliedDiscountInput {
    "Was discount applied automatically"
    automatic: Boolean!
    "Was discount combined with other discount"
    combined: Boolean!
    "Date of creation at point of creation (e.g. POS)"
    createdDate: Instant!
    "ID of original discount"
    discountId: UUID!
    id: UUID!
    "Name"
    name: String!
    "Percent discounted"
    percent: BigDecimal!
    "Type"
    type: DiscountType!
}

input UploadOrderInput {
    "Was order canceled"
    canceled: Boolean!
    "Date of creation at point of creation (e.g. POS)"
    createdDate: Instant!
    customer: CustomerSnapshotInput
    "Amount of discounts for all order items and order, if any present"
    discountAmount: AmountDataInput
    discounts: [ApplyOrderDiscountInput!]
    fiscalStatus: FiscalStatus
    guestCount: Int
    history: [OrderHistoryEntryInput!]
    id: UUID!
    "Amount of discounts for all order items, if any present"
    itemDiscount: AmountDataInput
    "Basket items"
    items: [UploadOrderItemInput!]!
    "Labels with additional information"
    labels: [OrderLabelInput!]
    "Date of last modification at point of creation (e.g. POS)"
    lastModifiedDate: Instant
    "Date of last payment"
    lastPayedDate: Instant
    loyaltyPoints: LoyaltyPointsInput
    "Assigned number"
    number: String!
    "Amount of discounts for order, if any present"
    orderDiscount: AmountDataInput
    "Name of organization"
    organizationName: String
    owner: SnapshotOrderEmployeeInput
    "Was order paid"
    payed: Boolean!
    "Related payments"
    payments: [UploadOrderPaymentInput!]
    refunded: Boolean
    "Result amount for all order items with discount deductions applied"
    resultAmount: AmountDataInput!
    shiftNumber: Int
    "Current status"
    status: OrderStatus!
    "ID of store where order was created"
    storeId: UUID!
    tableId: UUID
    "ID of terminal used for store creation"
    terminalId: UUID!
    "Name of terminal"
    terminalName: String!
    "Total amount for all order items"
    totalAmount: AmountDataInput!
    "Total Prime Price for all order items with modifiers"
    totalPrimePrice: AmountDataInput
    "Type"
    type: OrderType!
}

input UploadOrderItemInput {
    "Discounts applied to this item"
    appliedDiscounts: [UploadAppliedDiscountInput!]
    appliedModifiers: [AppliedModifierInput!]
    "Barcode"
    barcode: String
    "Comment"
    comment: String
    "Course which item belongs to"
    course: Int
    "Date of creation at point of creation (e.g. POS)"
    createdDate: Instant!
    "Total discount amount for designated quantity of item, if present"
    discountAmount: AmountDataInput
    "Guest who ordered this item"
    guest: Int!
    id: UUID!
    "Date of last modification at point of creation (e.g. POS)"
    lastModifiedDate: Instant
    "Name"
    name: String!
    "Type of item"
    positionTypeCode: PositionTypeCode!
    "Amount for designated quantity of item without modifiers"
    preTotalAmount: AmountDataInput
    "Prime price of stock unit which item is based on without modifiers"
    primePrice: AmountDataInput
    "Quantity of item"
    quantity: MeasureDataInput!
    "Result amount for order item with discount deductions applied"
    resultAmount: AmountDataInput!
    "Sale price of stock unit which item is based on"
    salePrice: AmountDataInput!
    "Tax system information"
    sno: Sno!
    "Current status"
    status: OrderItemStatus!
    "ID of stock unit on which order item is based"
    stockUnitId: UUID!
    "ID of associated tech card, if present"
    techCardId: UUID
    "Total amount for designated quantity of item with modifiers"
    totalAmount: AmountDataInput!
    "Total prime price of stock unit which item is based on with modifiers"
    totalPrimePrice: AmountDataInput
    "Amount for one unit of item"
    unitAmount: AmountDataInput!
    "Discount for one unit of item, if present"
    unitDiscountAmount: AmountDataInput
    "Quantity of one unit of item"
    unitQuantity: MeasureDataInput!
    "Tax size information"
    vatType: VatType!
    "Is item weighable"
    weighable: Boolean!
}

input UploadOrderPaymentInput {
    acquiringData: AcquiringDataInput
    "Amount payed"
    amount: AmountDataInput!
    "Date of creation at point of creation (e.g. POS)"
    createdDate: Instant!
    id: UUID!
    "Pay system used for payment"
    paySystem: OrderPaymentPaySystemInput!
    "Date payed"
    payedDate: Instant
    refundAcquiringData: AcquiringDataInput
    "Current status"
    status: PaymentStatus!
}

input UploadOrdersInput {
    "Orders to create or update"
    orders: [UploadOrderInput!]!
}

"Input for user group data"
input UserGroupInput {
    "ID of store in which user group is assigned. If empty, it's implied that employe's user group spans across all stores in organization"
    storeId: UUID
    "ID of the user group assigned to employee"
    userGroupId: UUID!
}

"Warehouse data"
input WarehouseCreateInput {
    "Is warehouse active"
    active: Boolean!
    "Address"
    addressName: String
    "Hours of business in arbitrary format"
    businessHours: String
    "Short description"
    description: String
    "E-mail"
    email: String
    "GPS latitude"
    gpsLatitude: String
    "GPS longitude"
    gpsLongitude: String
    "Name"
    name: String!
    "Phone (should match one of patterns: +7-XXX-XXX-XX-XX, 7-XXX-XXX-XX-XX, 8-XXX-XXX-XX-XX, where hyphens are optional)"
    phone: String
    "Is warehouse a location for picking up"
    pickupLocation: Boolean!
    "Is warehouse a shipping center"
    shippingCenter: Boolean!
    "Website"
    site: String
    "Order number of warehouse in list"
    sort: Int
    "Arbitrary symbolic code"
    symbolicCode: String
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String
}

"WarehouseCreateInputV2"
input WarehouseCreateInputV2 {
    "Is warehouse active"
    active: Boolean!
    "Address"
    addressName: String!
    "Whether warehouse archived or not"
    archived: Boolean
    "Date when warehouse has been archived"
    archivedDate: Instant
    "Hours of business in arbitrary format"
    businessHours: String
    "Short description"
    description: String
    "E-mail"
    email: String
    "GPS latitude"
    gpsLatitude: String!
    "GPS longitude"
    gpsLongitude: String!
    "Name"
    name: String!
    "Phone (should match one of patterns: +7-XXX-XXX-XX-XX, 7-XXX-XXX-XX-XX, 8-XXX-XXX-XX-XX, where hyphens are optional)"
    phone: String
    "Is warehouse a location for picking up"
    pickupLocation: Boolean!
    "Is warehouse a shipping center"
    shippingCenter: Boolean!
    "Website"
    site: String
    "Order number of warehouse in list"
    sort: Int
    "Corresponding store ids to whom particular warehouse belongs to"
    storeIds: [UUID!]
    "Arbitrary symbolic code"
    symbolicCode: String
    "By default warehouse timezone sets on an address base or Moscow timezone, user should verify whether timezone has been set correctly"
    timezoneVerified: Boolean!
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String!
}

input WarehouseFilterInput {
    archived: Boolean
    search: String
}

input WarehouseItemFilterInput {
    search: String
    warehouseId: UUID
}

input WarehouseItemHistoryFilterInput {
    dateFrom: LocalDate!
    dateTo: LocalDate!
    search: String
    warehouseId: UUID
}

input WarehouseItemLeftoverFilterInput {
    search: String
    sectionIds: [UUID!]
    types: [ProductType!]
    warehouseIds: [UUID!]
}

input WarehouseItemLeftoverSort {
    direction: SortDirection
    field: WarehouseItemLeftoverSortFields
}

"Warehouse data"
input WarehouseUpdateInput {
    "Is warehouse active"
    active: Boolean!
    "Address"
    addressName: String
    "Hours of business in arbitrary format"
    businessHours: String
    "Short description"
    description: String
    "E-mail"
    email: String
    "GPS latitude"
    gpsLatitude: String
    "GPS longitude"
    gpsLongitude: String
    "Warehouse ID"
    id: UUID!
    "Name"
    name: String!
    "Phone (should match one of patterns: +7-XXX-XXX-XX-XX, 7-XXX-XXX-XX-XX, 8-XXX-XXX-XX-XX, where hyphens are optional)"
    phone: String
    "Is warehouse a location for picking up"
    pickupLocation: Boolean!
    "Is warehouse a shipping center"
    shippingCenter: Boolean!
    "Website"
    site: String
    "Order number of warehouse in list"
    sort: Int
    "Arbitrary symbolic code"
    symbolicCode: String
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String
}

input WarehouseUpdateInputV2 {
    "Is warehouse active"
    active: Boolean
    addStoreIds: [UUID!]
    "Address"
    addressName: String
    "Whether warehouse archived or not"
    archived: Boolean
    "Date when warehouse has been archived"
    archivedDate: Instant
    "Hours of business in arbitrary format"
    businessHours: String
    "Short description"
    description: String
    "E-mail"
    email: String
    "GPS latitude"
    gpsLatitude: String
    "GPS longitude"
    gpsLongitude: String
    "Warehouse ID"
    id: UUID!
    "Name"
    name: String
    "Phone (should match one of patterns: +7-XXX-XXX-XX-XX, 7-XXX-XXX-XX-XX, 8-XXX-XXX-XX-XX, where hyphens are optional)"
    phone: String
    "Is warehouse a location for picking up"
    pickupLocation: Boolean
    removeStoreIds: [UUID!]
    "Is warehouse a shipping center"
    shippingCenter: Boolean
    "Website"
    site: String
    "Order number of warehouse in list"
    sort: Int
    "Arbitrary symbolic code"
    symbolicCode: String
    "By default warehouse timezone sets on an address base or Moscow timezone, user should verify whether timezone has been set correctly"
    timezoneVerified: Boolean
    "The name of the Time Zone in which the store operates (IANA Time Zone Database)"
    zoneId: String
}

input WarehousesPageableSort {
    direction: SortDirection
    field: WarehousesPageableSortField
}

input YandexMenuCategoryInput {
    available: Boolean!
    eatsId: Long!
    items: [YandexMenuItemInput!]
    """

    if menuSectionId is defined, then category will map on menuSection,
    else will be create new menu section
    """
    menuSectionId: UUID
    name: String!
    skip: Boolean
}

input YandexMenuItemInput {
    available: Boolean!
    decimalPrice: BigDecimal!
    description: String!
    eatsId: Long!
    images: [ImageInput!]
    """

    menuItemId and stockUnitId is mutually exclusive.
    if menuItemId is defined, then yandex menu item will map on pos menu item, and connected stock unit with them.
    """
    menuItemId: UUID
    name: String!
    price: BigDecimal!
    skip: Boolean
    """

    if stockUnitId is defined, then will be create new pos menu item, and it will map on stock unit.
    if menuItemId and stockUnitId are undefined, will be create new pos menu items, stock unit and new catalog
    """
    stockUnitId: UUID
    weight: String!
}
